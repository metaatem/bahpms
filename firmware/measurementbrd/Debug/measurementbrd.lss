
measurementbrd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000250  00800100  000023e0  00002474  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005a7  00800350  00800350  000026c4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000026c4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000026f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000530  00000000  00000000  00002730  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004e5f  00000000  00000000  00002c60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001fbe  00000000  00000000  00007abf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000031d4  00000000  00000000  00009a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c48  00000000  00000000  0000cc54  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000180c  00000000  00000000  0000d89c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000453e  00000000  00000000  0000f0a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003f8  00000000  00000000  000135e6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 01 	jmp	0x28c	; 0x28c <__ctors_end>
       4:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
       8:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
       c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      10:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      14:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      18:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      1c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      20:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      24:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      28:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      2c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      30:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <__vector_12>
      34:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      38:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      3c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      40:	0c 94 bc 07 	jmp	0xf78	; 0xf78 <__vector_16>
      44:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      48:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <__vector_18>
      4c:	0c 94 b3 0c 	jmp	0x1966	; 0x1966 <__vector_19>
      50:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      54:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      58:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      5c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      60:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      64:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      68:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      6c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      70:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      74:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      78:	0c 94 d8 07 	jmp	0xfb0	; 0xfb0 <__vector_30>
      7c:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      80:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      84:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>
      88:	0c 94 63 01 	jmp	0x2c6	; 0x2c6 <__bad_interrupt>

0000008c <__trampolines_end>:
      8c:	00 c0       	rjmp	.+0      	; 0x8e <__trampolines_end+0x2>
      8e:	c1 01       	movw	r24, r2
      90:	c3 03       	fmuls	r20, r19
      92:	02 c2       	rjmp	.+1028   	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
      94:	c6 06       	cpc	r12, r22
      96:	07 c7       	rjmp	.+3598   	; 0xea6 <eMBRegHoldingCB+0xc>
      98:	05 c5       	rjmp	.+2570   	; 0xaa4 <manage_4_BAT+0x21c>
      9a:	c4 04       	cpc	r12, r4
      9c:	cc 0c       	add	r12, r12
      9e:	0d cd       	rjmp	.-1510   	; 0xfffffaba <__eeprom_end+0xff7efaba>
      a0:	0f cf       	rjmp	.-482    	; 0xfffffec0 <__eeprom_end+0xff7efec0>
      a2:	ce 0e       	add	r12, r30
      a4:	0a ca       	rjmp	.-3052   	; 0xfffff4ba <__eeprom_end+0xff7ef4ba>
      a6:	cb 0b       	sbc	r28, r27
      a8:	c9 09       	sbc	r28, r9
      aa:	08 c8       	rjmp	.-4080   	; 0xfffff0bc <__eeprom_end+0xff7ef0bc>
      ac:	d8 18       	sub	r13, r8
      ae:	19 d9       	rcall	.-3534   	; 0xfffff2e2 <__eeprom_end+0xff7ef2e2>
      b0:	1b db       	rcall	.-2506   	; 0xfffff6e8 <__eeprom_end+0xff7ef6e8>
      b2:	da 1a       	sub	r13, r26
      b4:	1e de       	rcall	.-964    	; 0xfffffcf2 <__eeprom_end+0xff7efcf2>
      b6:	df 1f       	adc	r29, r31
      b8:	dd 1d       	adc	r29, r13
      ba:	1c dc       	rcall	.-1992   	; 0xfffff8f4 <__eeprom_end+0xff7ef8f4>
      bc:	14 d4       	rcall	.+2088   	; 0x8e6 <manage_4_BAT+0x5e>
      be:	d5 15       	cp	r29, r5
      c0:	d7 17       	cp	r29, r23
      c2:	16 d6       	rcall	.+3116   	; 0xcf0 <config_lora_module+0x66>
      c4:	d2 12       	cpse	r13, r18
      c6:	13 d3       	rcall	.+1574   	; 0x6ee <manage_3_BAT+0x72>
      c8:	11 d1       	rcall	.+546    	; 0x2ec <fetch_adc_values+0x22>
      ca:	d0 10       	cpse	r13, r0
      cc:	f0 30       	cpi	r31, 0x00	; 0
      ce:	31 f1       	breq	.+76     	; 0x11c <__trampolines_end+0x90>
      d0:	33 f3       	brvs	.-52     	; 0x9e <__trampolines_end+0x12>
      d2:	f2 32       	cpi	r31, 0x22	; 34
      d4:	36 f6       	brtc	.-116    	; 0x62 <__SREG__+0x23>
      d6:	f7 37       	cpi	r31, 0x77	; 119
      d8:	f5 35       	cpi	r31, 0x55	; 85
      da:	34 f4       	brge	.+12     	; 0xe8 <__trampolines_end+0x5c>
      dc:	3c fc       	.word	0xfc3c	; ????
      de:	fd 3d       	cpi	r31, 0xDD	; 221
      e0:	ff 3f       	cpi	r31, 0xFF	; 255
      e2:	3e fe       	.word	0xfe3e	; ????
      e4:	fa 3a       	cpi	r31, 0xAA	; 170
      e6:	3b fb       	.word	0xfb3b	; ????
      e8:	39 f9       	.word	0xf939	; ????
      ea:	f8 38       	cpi	r31, 0x88	; 136
      ec:	28 e8       	ldi	r18, 0x88	; 136
      ee:	e9 29       	or	r30, r9
      f0:	eb 2b       	or	r30, r27
      f2:	2a ea       	ldi	r18, 0xAA	; 170
      f4:	ee 2e       	mov	r14, r30
      f6:	2f ef       	ldi	r18, 0xFF	; 255
      f8:	2d ed       	ldi	r18, 0xDD	; 221
      fa:	ec 2c       	mov	r14, r12
      fc:	e4 24       	eor	r14, r4
      fe:	25 e5       	ldi	r18, 0x55	; 85
     100:	27 e7       	ldi	r18, 0x77	; 119
     102:	e6 26       	eor	r14, r22
     104:	22 e2       	ldi	r18, 0x22	; 34
     106:	e3 23       	and	r30, r19
     108:	e1 21       	and	r30, r1
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	a0 60       	ori	r26, 0x00	; 0
     10e:	61 a1       	ldd	r22, Z+33	; 0x21
     110:	63 a3       	std	Z+35, r22	; 0x23
     112:	a2 62       	ori	r26, 0x22	; 34
     114:	66 a6       	std	Z+46, r6	; 0x2e
     116:	a7 67       	ori	r26, 0x77	; 119
     118:	a5 65       	ori	r26, 0x55	; 85
     11a:	64 a4       	ldd	r6, Z+44	; 0x2c
     11c:	6c ac       	ldd	r6, Y+60	; 0x3c
     11e:	ad 6d       	ori	r26, 0xDD	; 221
     120:	af 6f       	ori	r26, 0xFF	; 255
     122:	6e ae       	std	Y+62, r6	; 0x3e
     124:	aa 6a       	ori	r26, 0xAA	; 170
     126:	6b ab       	std	Y+51, r22	; 0x33
     128:	69 a9       	ldd	r22, Y+49	; 0x31
     12a:	a8 68       	ori	r26, 0x88	; 136
     12c:	78 b8       	out	0x08, r7	; 8
     12e:	b9 79       	andi	r27, 0x99	; 153
     130:	bb 7b       	andi	r27, 0xBB	; 187
     132:	7a ba       	out	0x1a, r7	; 26
     134:	be 7e       	andi	r27, 0xEE	; 238
     136:	7f bf       	out	0x3f, r23	; 63
     138:	7d bd       	out	0x2d, r23	; 45
     13a:	bc 7c       	andi	r27, 0xCC	; 204
     13c:	b4 74       	andi	r27, 0x44	; 68
     13e:	75 b5       	in	r23, 0x25	; 37
     140:	77 b7       	in	r23, 0x37	; 55
     142:	b6 76       	andi	r27, 0x66	; 102
     144:	72 b2       	in	r7, 0x12	; 18
     146:	b3 73       	andi	r27, 0x33	; 51
     148:	b1 71       	andi	r27, 0x11	; 17
     14a:	70 b0       	in	r7, 0x00	; 0
     14c:	50 90 91 51 	lds	r5, 0x5191	; 0x805191 <__bss_end+0x489a>
     150:	93 53       	subi	r25, 0x33	; 51
     152:	52 92       	st	-Z, r5
     154:	96 56       	subi	r25, 0x66	; 102
     156:	57 97       	sbiw	r26, 0x17	; 23
     158:	55 95       	asr	r21
     15a:	94 54       	subi	r25, 0x44	; 68
     15c:	9c 5c       	subi	r25, 0xCC	; 204
     15e:	5d 9d       	mul	r21, r13
     160:	5f 9f       	mul	r21, r31
     162:	9e 5e       	subi	r25, 0xEE	; 238
     164:	5a 9a       	sbi	0x0b, 2	; 11
     166:	9b 5b       	subi	r25, 0xBB	; 187
     168:	99 59       	subi	r25, 0x99	; 153
     16a:	58 98       	cbi	0x0b, 0	; 11
     16c:	88 48       	sbci	r24, 0x88	; 136
     16e:	49 89       	ldd	r20, Y+17	; 0x11
     170:	4b 8b       	std	Y+19, r20	; 0x13
     172:	8a 4a       	sbci	r24, 0xAA	; 170
     174:	4e 8e       	std	Y+30, r4	; 0x1e
     176:	8f 4f       	sbci	r24, 0xFF	; 255
     178:	8d 4d       	sbci	r24, 0xDD	; 221
     17a:	4c 8c       	ldd	r4, Y+28	; 0x1c
     17c:	44 84       	ldd	r4, Z+12	; 0x0c
     17e:	85 45       	sbci	r24, 0x55	; 85
     180:	87 47       	sbci	r24, 0x77	; 119
     182:	46 86       	std	Z+14, r4	; 0x0e
     184:	82 42       	sbci	r24, 0x22	; 34
     186:	43 83       	std	Z+3, r20	; 0x03
     188:	41 81       	ldd	r20, Z+1	; 0x01
     18a:	80 40       	sbci	r24, 0x00	; 0

0000018c <aucCRCHi>:
     18c:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     19c:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     1ac:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     1bc:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     1cc:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     1dc:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     1ec:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     1fc:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     20c:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     21c:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     22c:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     23c:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     24c:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     25c:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     26c:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     27c:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

0000028c <__ctors_end>:
     28c:	11 24       	eor	r1, r1
     28e:	1f be       	out	0x3f, r1	; 63
     290:	cf ef       	ldi	r28, 0xFF	; 255
     292:	d0 e1       	ldi	r29, 0x10	; 16
     294:	de bf       	out	0x3e, r29	; 62
     296:	cd bf       	out	0x3d, r28	; 61

00000298 <__do_copy_data>:
     298:	13 e0       	ldi	r17, 0x03	; 3
     29a:	a0 e0       	ldi	r26, 0x00	; 0
     29c:	b1 e0       	ldi	r27, 0x01	; 1
     29e:	e0 ee       	ldi	r30, 0xE0	; 224
     2a0:	f3 e2       	ldi	r31, 0x23	; 35
     2a2:	02 c0       	rjmp	.+4      	; 0x2a8 <__do_copy_data+0x10>
     2a4:	05 90       	lpm	r0, Z+
     2a6:	0d 92       	st	X+, r0
     2a8:	a0 35       	cpi	r26, 0x50	; 80
     2aa:	b1 07       	cpc	r27, r17
     2ac:	d9 f7       	brne	.-10     	; 0x2a4 <__do_copy_data+0xc>

000002ae <__do_clear_bss>:
     2ae:	28 e0       	ldi	r18, 0x08	; 8
     2b0:	a0 e5       	ldi	r26, 0x50	; 80
     2b2:	b3 e0       	ldi	r27, 0x03	; 3
     2b4:	01 c0       	rjmp	.+2      	; 0x2b8 <.do_clear_bss_start>

000002b6 <.do_clear_bss_loop>:
     2b6:	1d 92       	st	X+, r1

000002b8 <.do_clear_bss_start>:
     2b8:	a7 3f       	cpi	r26, 0xF7	; 247
     2ba:	b2 07       	cpc	r27, r18
     2bc:	e1 f7       	brne	.-8      	; 0x2b6 <.do_clear_bss_loop>
     2be:	0e 94 c4 06 	call	0xd88	; 0xd88 <main>
     2c2:	0c 94 ee 11 	jmp	0x23dc	; 0x23dc <_exit>

000002c6 <__bad_interrupt>:
     2c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002ca <fetch_adc_values>:
	/* --- Write settings to holding registers --- */
	usRegHoldingBuf[0] = (int16_t) MANUAL_MODE;
	usRegHoldingBuf[1] = (int16_t) NUM_BATS;
	usRegHoldingBuf[2] = (int16_t) BAT_CELLS;
	usRegHoldingBuf[3] = (int16_t) *bat_active;
	usRegHoldingBuf[4] = (int16_t) *bat_chrgng;
     2ca:	cf 93       	push	r28
     2cc:	df 93       	push	r29
     2ce:	85 e0       	ldi	r24, 0x05	; 5
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     2d6:	c2 e6       	ldi	r28, 0x62	; 98
     2d8:	d3 e0       	ldi	r29, 0x03	; 3
     2da:	99 83       	std	Y+1, r25	; 0x01
     2dc:	88 83       	st	Y, r24
     2de:	80 e0       	ldi	r24, 0x00	; 0
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <spi_rx16_adc_portb>
     2e6:	9b 83       	std	Y+3, r25	; 0x03
     2e8:	8a 83       	std	Y+2, r24	; 0x02
     2ea:	86 e0       	ldi	r24, 0x06	; 6
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     2f2:	9d 83       	std	Y+5, r25	; 0x05
     2f4:	8c 83       	std	Y+4, r24	; 0x04
     2f6:	87 e0       	ldi	r24, 0x07	; 7
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     2fe:	9f 83       	std	Y+7, r25	; 0x07
     300:	8e 83       	std	Y+6, r24	; 0x06
     302:	84 e0       	ldi	r24, 0x04	; 4
     304:	90 e0       	ldi	r25, 0x00	; 0
     306:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     30a:	99 87       	std	Y+9, r25	; 0x09
     30c:	88 87       	std	Y+8, r24	; 0x08
     30e:	83 e0       	ldi	r24, 0x03	; 3
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     316:	9b 87       	std	Y+11, r25	; 0x0b
     318:	8a 87       	std	Y+10, r24	; 0x0a
     31a:	82 e0       	ldi	r24, 0x02	; 2
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     322:	9d 87       	std	Y+13, r25	; 0x0d
     324:	8c 87       	std	Y+12, r24	; 0x0c
     326:	81 e0       	ldi	r24, 0x01	; 1
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <spi_rx16_adc_portc>
     32e:	9f 87       	std	Y+15, r25	; 0x0f
     330:	8e 87       	std	Y+14, r24	; 0x0e
     332:	df 91       	pop	r29
     334:	cf 91       	pop	r28
     336:	08 95       	ret

00000338 <get_volts_next_bat>:
     338:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <NUM_BATS>
     33c:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <NUM_BATS+0x1>
     340:	20 81       	ld	r18, Z
     342:	31 81       	ldd	r19, Z+1	; 0x01
     344:	23 30       	cpi	r18, 0x03	; 3
     346:	31 05       	cpc	r19, r1
     348:	89 f0       	breq	.+34     	; 0x36c <get_volts_next_bat+0x34>
     34a:	24 30       	cpi	r18, 0x04	; 4
     34c:	31 05       	cpc	r19, r1
     34e:	39 f1       	breq	.+78     	; 0x39e <get_volts_next_bat+0x66>
     350:	22 30       	cpi	r18, 0x02	; 2
     352:	31 05       	cpc	r19, r1
     354:	79 f5       	brne	.+94     	; 0x3b4 <get_volts_next_bat+0x7c>
     356:	fc 01       	movw	r30, r24
     358:	31 96       	adiw	r30, 0x01	; 1
     35a:	e1 70       	andi	r30, 0x01	; 1
     35c:	ff 27       	eor	r31, r31
     35e:	ee 0f       	add	r30, r30
     360:	ff 1f       	adc	r31, r31
     362:	ee 59       	subi	r30, 0x9E	; 158
     364:	fc 4f       	sbci	r31, 0xFC	; 252
     366:	80 81       	ld	r24, Z
     368:	91 81       	ldd	r25, Z+1	; 0x01
     36a:	08 95       	ret
     36c:	ac 01       	movw	r20, r24
     36e:	4f 5f       	subi	r20, 0xFF	; 255
     370:	5f 4f       	sbci	r21, 0xFF	; 255
     372:	9a 01       	movw	r18, r20
     374:	ab ea       	ldi	r26, 0xAB	; 171
     376:	ba ea       	ldi	r27, 0xAA	; 170
     378:	0e 94 d6 11 	call	0x23ac	; 0x23ac <__umulhisi3>
     37c:	96 95       	lsr	r25
     37e:	87 95       	ror	r24
     380:	9c 01       	movw	r18, r24
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	82 0f       	add	r24, r18
     388:	93 1f       	adc	r25, r19
     38a:	fa 01       	movw	r30, r20
     38c:	e8 1b       	sub	r30, r24
     38e:	f9 0b       	sbc	r31, r25
     390:	ee 0f       	add	r30, r30
     392:	ff 1f       	adc	r31, r31
     394:	ee 59       	subi	r30, 0x9E	; 158
     396:	fc 4f       	sbci	r31, 0xFC	; 252
     398:	80 81       	ld	r24, Z
     39a:	91 81       	ldd	r25, Z+1	; 0x01
     39c:	08 95       	ret
     39e:	fc 01       	movw	r30, r24
     3a0:	31 96       	adiw	r30, 0x01	; 1
     3a2:	e3 70       	andi	r30, 0x03	; 3
     3a4:	ff 27       	eor	r31, r31
     3a6:	ee 0f       	add	r30, r30
     3a8:	ff 1f       	adc	r31, r31
     3aa:	ee 59       	subi	r30, 0x9E	; 158
     3ac:	fc 4f       	sbci	r31, 0xFC	; 252
     3ae:	80 81       	ld	r24, Z
     3b0:	91 81       	ldd	r25, Z+1	; 0x01
     3b2:	08 95       	ret
     3b4:	08 95       	ret

000003b6 <assert_bats_ok>:
     3b6:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <NUM_BATS>
     3ba:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <NUM_BATS+0x1>
     3be:	80 81       	ld	r24, Z
     3c0:	91 81       	ldd	r25, Z+1	; 0x01
     3c2:	83 30       	cpi	r24, 0x03	; 3
     3c4:	91 05       	cpc	r25, r1
     3c6:	f1 f0       	breq	.+60     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     3c8:	84 30       	cpi	r24, 0x04	; 4
     3ca:	91 05       	cpc	r25, r1
     3cc:	f1 f1       	breq	.+124    	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
     3ce:	02 97       	sbiw	r24, 0x02	; 2
     3d0:	09 f0       	breq	.+2      	; 0x3d4 <assert_bats_ok+0x1e>
     3d2:	69 c0       	rjmp	.+210    	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
     3d4:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <usRegInputBuf>
     3d8:	90 91 63 03 	lds	r25, 0x0363	; 0x800363 <usRegInputBuf+0x1>
     3dc:	8b 50       	subi	r24, 0x0B	; 11
     3de:	9f 4b       	sbci	r25, 0xBF	; 191
     3e0:	88 3d       	cpi	r24, 0xD8	; 216
     3e2:	90 43       	sbci	r25, 0x30	; 48
     3e4:	60 f4       	brcc	.+24     	; 0x3fe <assert_bats_ok+0x48>
     3e6:	20 91 64 03 	lds	r18, 0x0364	; 0x800364 <usRegInputBuf+0x2>
     3ea:	30 91 65 03 	lds	r19, 0x0365	; 0x800365 <usRegInputBuf+0x3>
     3ee:	2b 50       	subi	r18, 0x0B	; 11
     3f0:	3f 4b       	sbci	r19, 0xBF	; 191
     3f2:	81 e0       	ldi	r24, 0x01	; 1
     3f4:	28 3d       	cpi	r18, 0xD8	; 216
     3f6:	30 43       	sbci	r19, 0x30	; 48
     3f8:	18 f0       	brcs	.+6      	; 0x400 <__LOCK_REGION_LENGTH__>
     3fa:	80 e0       	ldi	r24, 0x00	; 0
     3fc:	01 c0       	rjmp	.+2      	; 0x400 <__LOCK_REGION_LENGTH__>
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	81 70       	andi	r24, 0x01	; 1
     402:	08 95       	ret
     404:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <usRegInputBuf>
     408:	90 91 63 03 	lds	r25, 0x0363	; 0x800363 <usRegInputBuf+0x1>
     40c:	8b 50       	subi	r24, 0x0B	; 11
     40e:	9f 4b       	sbci	r25, 0xBF	; 191
     410:	88 3d       	cpi	r24, 0xD8	; 216
     412:	90 43       	sbci	r25, 0x30	; 48
     414:	a8 f4       	brcc	.+42     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     416:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <usRegInputBuf+0x2>
     41a:	90 91 65 03 	lds	r25, 0x0365	; 0x800365 <usRegInputBuf+0x3>
     41e:	8b 50       	subi	r24, 0x0B	; 11
     420:	9f 4b       	sbci	r25, 0xBF	; 191
     422:	88 3d       	cpi	r24, 0xD8	; 216
     424:	90 43       	sbci	r25, 0x30	; 48
     426:	70 f4       	brcc	.+28     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
     428:	20 91 66 03 	lds	r18, 0x0366	; 0x800366 <usRegInputBuf+0x4>
     42c:	30 91 67 03 	lds	r19, 0x0367	; 0x800367 <usRegInputBuf+0x5>
     430:	2b 50       	subi	r18, 0x0B	; 11
     432:	3f 4b       	sbci	r19, 0xBF	; 191
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	28 3d       	cpi	r18, 0xD8	; 216
     438:	30 43       	sbci	r19, 0x30	; 48
     43a:	28 f0       	brcs	.+10     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	03 c0       	rjmp	.+6      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     440:	80 e0       	ldi	r24, 0x00	; 0
     442:	01 c0       	rjmp	.+2      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	81 70       	andi	r24, 0x01	; 1
     448:	08 95       	ret
     44a:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <usRegInputBuf>
     44e:	90 91 63 03 	lds	r25, 0x0363	; 0x800363 <usRegInputBuf+0x1>
     452:	8b 50       	subi	r24, 0x0B	; 11
     454:	9f 4b       	sbci	r25, 0xBF	; 191
     456:	88 3d       	cpi	r24, 0xD8	; 216
     458:	90 43       	sbci	r25, 0x30	; 48
     45a:	f0 f4       	brcc	.+60     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
     45c:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <usRegInputBuf+0x2>
     460:	90 91 65 03 	lds	r25, 0x0365	; 0x800365 <usRegInputBuf+0x3>
     464:	8b 50       	subi	r24, 0x0B	; 11
     466:	9f 4b       	sbci	r25, 0xBF	; 191
     468:	88 3d       	cpi	r24, 0xD8	; 216
     46a:	90 43       	sbci	r25, 0x30	; 48
     46c:	b8 f4       	brcc	.+46     	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
     46e:	80 91 66 03 	lds	r24, 0x0366	; 0x800366 <usRegInputBuf+0x4>
     472:	90 91 67 03 	lds	r25, 0x0367	; 0x800367 <usRegInputBuf+0x5>
     476:	8b 50       	subi	r24, 0x0B	; 11
     478:	9f 4b       	sbci	r25, 0xBF	; 191
     47a:	88 3d       	cpi	r24, 0xD8	; 216
     47c:	90 43       	sbci	r25, 0x30	; 48
     47e:	80 f4       	brcc	.+32     	; 0x4a0 <__LOCK_REGION_LENGTH__+0xa0>
     480:	20 91 68 03 	lds	r18, 0x0368	; 0x800368 <usRegInputBuf+0x6>
     484:	30 91 69 03 	lds	r19, 0x0369	; 0x800369 <usRegInputBuf+0x7>
     488:	2b 50       	subi	r18, 0x0B	; 11
     48a:	3f 4b       	sbci	r19, 0xBF	; 191
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	28 3d       	cpi	r18, 0xD8	; 216
     490:	30 43       	sbci	r19, 0x30	; 48
     492:	38 f0       	brcs	.+14     	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     494:	80 e0       	ldi	r24, 0x00	; 0
     496:	05 c0       	rjmp	.+10     	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     498:	80 e0       	ldi	r24, 0x00	; 0
     49a:	03 c0       	rjmp	.+6      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     49c:	80 e0       	ldi	r24, 0x00	; 0
     49e:	01 c0       	rjmp	.+2      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     4a0:	80 e0       	ldi	r24, 0x00	; 0
     4a2:	81 70       	andi	r24, 0x01	; 1
     4a4:	08 95       	ret
     4a6:	80 e0       	ldi	r24, 0x00	; 0
     4a8:	08 95       	ret

000004aa <stop_chargng_bat>:
     4aa:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     4ae:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     4b2:	80 81       	ld	r24, Z
     4b4:	91 81       	ldd	r25, Z+1	; 0x01
     4b6:	85 30       	cpi	r24, 0x05	; 5
     4b8:	91 05       	cpc	r25, r1
     4ba:	61 f0       	breq	.+24     	; 0x4d4 <stop_chargng_bat+0x2a>
     4bc:	18 f4       	brcc	.+6      	; 0x4c4 <stop_chargng_bat+0x1a>
     4be:	04 97       	sbiw	r24, 0x04	; 4
     4c0:	39 f0       	breq	.+14     	; 0x4d0 <stop_chargng_bat+0x26>
     4c2:	08 95       	ret
     4c4:	86 30       	cpi	r24, 0x06	; 6
     4c6:	91 05       	cpc	r25, r1
     4c8:	39 f0       	breq	.+14     	; 0x4d8 <stop_chargng_bat+0x2e>
     4ca:	07 97       	sbiw	r24, 0x07	; 7
     4cc:	39 f0       	breq	.+14     	; 0x4dc <stop_chargng_bat+0x32>
     4ce:	08 95       	ret
     4d0:	df 98       	cbi	0x1b, 7	; 27
     4d2:	08 95       	ret
     4d4:	dc 98       	cbi	0x1b, 4	; 27
     4d6:	08 95       	ret
     4d8:	de 98       	cbi	0x1b, 6	; 27
     4da:	08 95       	ret
     4dc:	dd 98       	cbi	0x1b, 5	; 27
     4de:	08 95       	ret

000004e0 <manage_2_BAT>:
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     4e8:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     4ec:	80 81       	ld	r24, Z
     4ee:	81 11       	cpse	r24, r1
     4f0:	4e c0       	rjmp	.+156    	; 0x58e <manage_2_BAT+0xae>
     4f2:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     4f6:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     4fa:	c0 81       	ld	r28, Z
     4fc:	d1 81       	ldd	r29, Z+1	; 0x01
     4fe:	fe 01       	movw	r30, r28
     500:	e3 70       	andi	r30, 0x03	; 3
     502:	ff 27       	eor	r31, r31
     504:	ee 0f       	add	r30, r30
     506:	ff 1f       	adc	r31, r31
     508:	ee 59       	subi	r30, 0x9E	; 158
     50a:	fc 4f       	sbci	r31, 0xFC	; 252
     50c:	60 81       	ld	r22, Z
     50e:	71 81       	ldd	r23, Z+1	; 0x01
     510:	80 e0       	ldi	r24, 0x00	; 0
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     518:	20 e0       	ldi	r18, 0x00	; 0
     51a:	3b e0       	ldi	r19, 0x0B	; 11
     51c:	4f e3       	ldi	r20, 0x3F	; 63
     51e:	57 e4       	ldi	r21, 0x47	; 71
     520:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     524:	18 16       	cp	r1, r24
     526:	0c f4       	brge	.+2      	; 0x52a <manage_2_BAT+0x4a>
     528:	a6 c0       	rjmp	.+332    	; 0x676 <manage_2_BAT+0x196>
     52a:	ce 01       	movw	r24, r28
     52c:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     530:	bc 01       	movw	r22, r24
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	3b e0       	ldi	r19, 0x0B	; 11
     53e:	4f e3       	ldi	r20, 0x3F	; 63
     540:	57 e4       	ldi	r21, 0x47	; 71
     542:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     546:	18 16       	cp	r1, r24
     548:	3c f0       	brlt	.+14     	; 0x558 <manage_2_BAT+0x78>
     54a:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     54e:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	80 83       	st	Z, r24
     556:	8f c0       	rjmp	.+286    	; 0x676 <manage_2_BAT+0x196>
     558:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <usRegInputBuf+0x10>
     55c:	90 91 73 03 	lds	r25, 0x0373	; 0x800373 <usRegInputBuf+0x11>
     560:	89 2b       	or	r24, r25
     562:	09 f0       	breq	.+2      	; 0x566 <manage_2_BAT+0x86>
     564:	88 c0       	rjmp	.+272    	; 0x676 <manage_2_BAT+0x196>
     566:	db 9a       	sbi	0x1b, 3	; 27
     568:	d8 9a       	sbi	0x1b, 0	; 27
     56a:	df 9a       	sbi	0x1b, 7	; 27
     56c:	e2 e6       	ldi	r30, 0x62	; 98
     56e:	f3 e0       	ldi	r31, 0x03	; 3
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	91 8b       	std	Z+17, r25	; 0x11
     576:	80 8b       	std	Z+16, r24	; 0x10
     578:	84 e0       	ldi	r24, 0x04	; 4
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	93 8b       	std	Z+19, r25	; 0x13
     57e:	82 8b       	std	Z+18, r24	; 0x12
     580:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     584:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	80 83       	st	Z, r24
     58c:	74 c0       	rjmp	.+232    	; 0x676 <manage_2_BAT+0x196>
     58e:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     592:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     596:	c0 81       	ld	r28, Z
     598:	d1 81       	ldd	r29, Z+1	; 0x01
     59a:	fe 01       	movw	r30, r28
     59c:	e3 70       	andi	r30, 0x03	; 3
     59e:	ff 27       	eor	r31, r31
     5a0:	ee 0f       	add	r30, r30
     5a2:	ff 1f       	adc	r31, r31
     5a4:	ee 59       	subi	r30, 0x9E	; 158
     5a6:	fc 4f       	sbci	r31, 0xFC	; 252
     5a8:	60 81       	ld	r22, Z
     5aa:	71 81       	ldd	r23, Z+1	; 0x01
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     5b4:	20 e0       	ldi	r18, 0x00	; 0
     5b6:	3b e0       	ldi	r19, 0x0B	; 11
     5b8:	4f e3       	ldi	r20, 0x3F	; 63
     5ba:	57 e4       	ldi	r21, 0x47	; 71
     5bc:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     5c0:	18 16       	cp	r1, r24
     5c2:	e4 f1       	brlt	.+120    	; 0x63c <manage_2_BAT+0x15c>
     5c4:	ce 01       	movw	r24, r28
     5c6:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     5ca:	bc 01       	movw	r22, r24
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	3b e0       	ldi	r19, 0x0B	; 11
     5d8:	4f e3       	ldi	r20, 0x3F	; 63
     5da:	57 e4       	ldi	r21, 0x47	; 71
     5dc:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     5e0:	18 16       	cp	r1, r24
     5e2:	3c f0       	brlt	.+14     	; 0x5f2 <manage_2_BAT+0x112>
     5e4:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     5e8:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     5ec:	81 e0       	ldi	r24, 0x01	; 1
     5ee:	80 83       	st	Z, r24
     5f0:	42 c0       	rjmp	.+132    	; 0x676 <manage_2_BAT+0x196>
     5f2:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <usRegInputBuf+0x10>
     5f6:	90 91 73 03 	lds	r25, 0x0373	; 0x800373 <usRegInputBuf+0x11>
     5fa:	00 97       	sbiw	r24, 0x00	; 0
     5fc:	19 f0       	breq	.+6      	; 0x604 <manage_2_BAT+0x124>
     5fe:	01 97       	sbiw	r24, 0x01	; 1
     600:	81 f0       	breq	.+32     	; 0x622 <manage_2_BAT+0x142>
     602:	39 c0       	rjmp	.+114    	; 0x676 <manage_2_BAT+0x196>
     604:	dc 98       	cbi	0x1b, 4	; 27
     606:	db 9a       	sbi	0x1b, 3	; 27
     608:	d8 9a       	sbi	0x1b, 0	; 27
     60a:	df 9a       	sbi	0x1b, 7	; 27
     60c:	e2 e6       	ldi	r30, 0x62	; 98
     60e:	f3 e0       	ldi	r31, 0x03	; 3
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	91 8b       	std	Z+17, r25	; 0x11
     616:	80 8b       	std	Z+16, r24	; 0x10
     618:	84 e0       	ldi	r24, 0x04	; 4
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	93 8b       	std	Z+19, r25	; 0x13
     61e:	82 8b       	std	Z+18, r24	; 0x12
     620:	2a c0       	rjmp	.+84     	; 0x676 <manage_2_BAT+0x196>
     622:	df 98       	cbi	0x1b, 7	; 27
     624:	d8 98       	cbi	0x1b, 0	; 27
     626:	db 98       	cbi	0x1b, 3	; 27
     628:	dc 9a       	sbi	0x1b, 4	; 27
     62a:	e2 e6       	ldi	r30, 0x62	; 98
     62c:	f3 e0       	ldi	r31, 0x03	; 3
     62e:	11 8a       	std	Z+17, r1	; 0x11
     630:	10 8a       	std	Z+16, r1	; 0x10
     632:	85 e0       	ldi	r24, 0x05	; 5
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	93 8b       	std	Z+19, r25	; 0x13
     638:	82 8b       	std	Z+18, r24	; 0x12
     63a:	1d c0       	rjmp	.+58     	; 0x676 <manage_2_BAT+0x196>
     63c:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     640:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     644:	01 90       	ld	r0, Z+
     646:	f0 81       	ld	r31, Z
     648:	e0 2d       	mov	r30, r0
     64a:	e3 70       	andi	r30, 0x03	; 3
     64c:	ff 27       	eor	r31, r31
     64e:	ee 0f       	add	r30, r30
     650:	ff 1f       	adc	r31, r31
     652:	ee 59       	subi	r30, 0x9E	; 158
     654:	fc 4f       	sbci	r31, 0xFC	; 252
     656:	60 81       	ld	r22, Z
     658:	71 81       	ldd	r23, Z+1	; 0x01
     65a:	80 e0       	ldi	r24, 0x00	; 0
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	32 ee       	ldi	r19, 0xE2	; 226
     666:	4f e6       	ldi	r20, 0x6F	; 111
     668:	57 e4       	ldi	r21, 0x47	; 71
     66a:	0e 94 af 11 	call	0x235e	; 0x235e <__gesf2>
     66e:	88 23       	and	r24, r24
     670:	14 f0       	brlt	.+4      	; 0x676 <manage_2_BAT+0x196>
     672:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	08 95       	ret

0000067c <manage_3_BAT>:
     67c:	cf 92       	push	r12
     67e:	df 92       	push	r13
     680:	ef 92       	push	r14
     682:	ff 92       	push	r15
     684:	cf 93       	push	r28
     686:	df 93       	push	r29
     688:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     68c:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     690:	80 81       	ld	r24, Z
     692:	81 11       	cpse	r24, r1
     694:	46 c0       	rjmp	.+140    	; 0x722 <manage_3_BAT+0xa6>
     696:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     69a:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     69e:	c0 81       	ld	r28, Z
     6a0:	d1 81       	ldd	r29, Z+1	; 0x01
     6a2:	fe 01       	movw	r30, r28
     6a4:	e3 70       	andi	r30, 0x03	; 3
     6a6:	ff 27       	eor	r31, r31
     6a8:	ee 0f       	add	r30, r30
     6aa:	ff 1f       	adc	r31, r31
     6ac:	ee 59       	subi	r30, 0x9E	; 158
     6ae:	fc 4f       	sbci	r31, 0xFC	; 252
     6b0:	60 81       	ld	r22, Z
     6b2:	71 81       	ldd	r23, Z+1	; 0x01
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     6bc:	20 e0       	ldi	r18, 0x00	; 0
     6be:	3b e0       	ldi	r19, 0x0B	; 11
     6c0:	4f e3       	ldi	r20, 0x3F	; 63
     6c2:	57 e4       	ldi	r21, 0x47	; 71
     6c4:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     6c8:	18 16       	cp	r1, r24
     6ca:	0c f4       	brge	.+2      	; 0x6ce <manage_3_BAT+0x52>
     6cc:	d6 c0       	rjmp	.+428    	; 0x87a <manage_3_BAT+0x1fe>
     6ce:	ce 01       	movw	r24, r28
     6d0:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     6d4:	bc 01       	movw	r22, r24
     6d6:	80 e0       	ldi	r24, 0x00	; 0
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     6de:	20 e0       	ldi	r18, 0x00	; 0
     6e0:	3b e0       	ldi	r19, 0x0B	; 11
     6e2:	4f e3       	ldi	r20, 0x3F	; 63
     6e4:	57 e4       	ldi	r21, 0x47	; 71
     6e6:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     6ea:	18 16       	cp	r1, r24
     6ec:	3c f0       	brlt	.+14     	; 0x6fc <manage_3_BAT+0x80>
     6ee:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     6f2:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	80 83       	st	Z, r24
     6fa:	bf c0       	rjmp	.+382    	; 0x87a <manage_3_BAT+0x1fe>
     6fc:	cd 2b       	or	r28, r29
     6fe:	09 f0       	breq	.+2      	; 0x702 <manage_3_BAT+0x86>
     700:	bc c0       	rjmp	.+376    	; 0x87a <manage_3_BAT+0x1fe>
     702:	db 9a       	sbi	0x1b, 3	; 27
     704:	d8 9a       	sbi	0x1b, 0	; 27
     706:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     70a:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	91 83       	std	Z+1, r25	; 0x01
     714:	80 83       	st	Z, r24
     716:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     71a:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     71e:	80 83       	st	Z, r24
     720:	ac c0       	rjmp	.+344    	; 0x87a <manage_3_BAT+0x1fe>
     722:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     726:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     72a:	c0 81       	ld	r28, Z
     72c:	d1 81       	ldd	r29, Z+1	; 0x01
     72e:	fe 01       	movw	r30, r28
     730:	e3 70       	andi	r30, 0x03	; 3
     732:	ff 27       	eor	r31, r31
     734:	ee 0f       	add	r30, r30
     736:	ff 1f       	adc	r31, r31
     738:	ee 59       	subi	r30, 0x9E	; 158
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	60 81       	ld	r22, Z
     73e:	71 81       	ldd	r23, Z+1	; 0x01
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     748:	6b 01       	movw	r12, r22
     74a:	7c 01       	movw	r14, r24
     74c:	20 e0       	ldi	r18, 0x00	; 0
     74e:	3b e0       	ldi	r19, 0x0B	; 11
     750:	4f e3       	ldi	r20, 0x3F	; 63
     752:	57 e4       	ldi	r21, 0x47	; 71
     754:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     758:	18 16       	cp	r1, r24
     75a:	ec f1       	brlt	.+122    	; 0x7d6 <manage_3_BAT+0x15a>
     75c:	ce 01       	movw	r24, r28
     75e:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     762:	bc 01       	movw	r22, r24
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     76c:	20 e0       	ldi	r18, 0x00	; 0
     76e:	3b e0       	ldi	r19, 0x0B	; 11
     770:	4f e3       	ldi	r20, 0x3F	; 63
     772:	57 e4       	ldi	r21, 0x47	; 71
     774:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     778:	18 16       	cp	r1, r24
     77a:	3c f0       	brlt	.+14     	; 0x78a <manage_3_BAT+0x10e>
     77c:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     780:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	80 83       	st	Z, r24
     788:	78 c0       	rjmp	.+240    	; 0x87a <manage_3_BAT+0x1fe>
     78a:	c1 30       	cpi	r28, 0x01	; 1
     78c:	d1 05       	cpc	r29, r1
     78e:	79 f0       	breq	.+30     	; 0x7ae <manage_3_BAT+0x132>
     790:	18 f0       	brcs	.+6      	; 0x798 <manage_3_BAT+0x11c>
     792:	22 97       	sbiw	r28, 0x02	; 2
     794:	b9 f0       	breq	.+46     	; 0x7c4 <manage_3_BAT+0x148>
     796:	71 c0       	rjmp	.+226    	; 0x87a <manage_3_BAT+0x1fe>
     798:	db 9a       	sbi	0x1b, 3	; 27
     79a:	d8 9a       	sbi	0x1b, 0	; 27
     79c:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     7a0:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	91 83       	std	Z+1, r25	; 0x01
     7aa:	80 83       	st	Z, r24
     7ac:	66 c0       	rjmp	.+204    	; 0x87a <manage_3_BAT+0x1fe>
     7ae:	d8 98       	cbi	0x1b, 0	; 27
     7b0:	da 9a       	sbi	0x1b, 2	; 27
     7b2:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     7b6:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     7ba:	82 e0       	ldi	r24, 0x02	; 2
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	91 83       	std	Z+1, r25	; 0x01
     7c0:	80 83       	st	Z, r24
     7c2:	5b c0       	rjmp	.+182    	; 0x87a <manage_3_BAT+0x1fe>
     7c4:	da 98       	cbi	0x1b, 2	; 27
     7c6:	db 98       	cbi	0x1b, 3	; 27
     7c8:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     7cc:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     7d0:	11 82       	std	Z+1, r1	; 0x01
     7d2:	10 82       	st	Z, r1
     7d4:	52 c0       	rjmp	.+164    	; 0x87a <manage_3_BAT+0x1fe>
     7d6:	20 e0       	ldi	r18, 0x00	; 0
     7d8:	35 ee       	ldi	r19, 0xE5	; 229
     7da:	47 e5       	ldi	r20, 0x57	; 87
     7dc:	57 e4       	ldi	r21, 0x47	; 71
     7de:	c7 01       	movw	r24, r14
     7e0:	b6 01       	movw	r22, r12
     7e2:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     7e6:	18 16       	cp	r1, r24
     7e8:	5c f1       	brlt	.+86     	; 0x840 <manage_3_BAT+0x1c4>
     7ea:	c1 30       	cpi	r28, 0x01	; 1
     7ec:	d1 05       	cpc	r29, r1
     7ee:	81 f0       	breq	.+32     	; 0x810 <manage_3_BAT+0x194>
     7f0:	18 f0       	brcs	.+6      	; 0x7f8 <manage_3_BAT+0x17c>
     7f2:	22 97       	sbiw	r28, 0x02	; 2
     7f4:	c9 f0       	breq	.+50     	; 0x828 <manage_3_BAT+0x1ac>
     7f6:	41 c0       	rjmp	.+130    	; 0x87a <manage_3_BAT+0x1fe>
     7f8:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     7fc:	de 9a       	sbi	0x1b, 6	; 27
     7fe:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     802:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     806:	86 e0       	ldi	r24, 0x06	; 6
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	91 83       	std	Z+1, r25	; 0x01
     80c:	80 83       	st	Z, r24
     80e:	35 c0       	rjmp	.+106    	; 0x87a <manage_3_BAT+0x1fe>
     810:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     814:	df 9a       	sbi	0x1b, 7	; 27
     816:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     81a:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     81e:	84 e0       	ldi	r24, 0x04	; 4
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	91 83       	std	Z+1, r25	; 0x01
     824:	80 83       	st	Z, r24
     826:	29 c0       	rjmp	.+82     	; 0x87a <manage_3_BAT+0x1fe>
     828:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     82c:	dc 9a       	sbi	0x1b, 4	; 27
     82e:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     832:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     836:	85 e0       	ldi	r24, 0x05	; 5
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	91 83       	std	Z+1, r25	; 0x01
     83c:	80 83       	st	Z, r24
     83e:	1d c0       	rjmp	.+58     	; 0x87a <manage_3_BAT+0x1fe>
     840:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     844:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     848:	01 90       	ld	r0, Z+
     84a:	f0 81       	ld	r31, Z
     84c:	e0 2d       	mov	r30, r0
     84e:	e3 70       	andi	r30, 0x03	; 3
     850:	ff 27       	eor	r31, r31
     852:	ee 0f       	add	r30, r30
     854:	ff 1f       	adc	r31, r31
     856:	ee 59       	subi	r30, 0x9E	; 158
     858:	fc 4f       	sbci	r31, 0xFC	; 252
     85a:	60 81       	ld	r22, Z
     85c:	71 81       	ldd	r23, Z+1	; 0x01
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	32 ee       	ldi	r19, 0xE2	; 226
     86a:	4f e6       	ldi	r20, 0x6F	; 111
     86c:	57 e4       	ldi	r21, 0x47	; 71
     86e:	0e 94 af 11 	call	0x235e	; 0x235e <__gesf2>
     872:	88 23       	and	r24, r24
     874:	14 f0       	brlt	.+4      	; 0x87a <manage_3_BAT+0x1fe>
     876:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	ff 90       	pop	r15
     880:	ef 90       	pop	r14
     882:	df 90       	pop	r13
     884:	cf 90       	pop	r12
     886:	08 95       	ret

00000888 <manage_4_BAT>:
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     890:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     894:	80 81       	ld	r24, Z
     896:	81 11       	cpse	r24, r1
     898:	5d c0       	rjmp	.+186    	; 0x954 <manage_4_BAT+0xcc>
     89a:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     89e:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     8a2:	c0 81       	ld	r28, Z
     8a4:	d1 81       	ldd	r29, Z+1	; 0x01
     8a6:	fe 01       	movw	r30, r28
     8a8:	e3 70       	andi	r30, 0x03	; 3
     8aa:	ff 27       	eor	r31, r31
     8ac:	ee 0f       	add	r30, r30
     8ae:	ff 1f       	adc	r31, r31
     8b0:	ee 59       	subi	r30, 0x9E	; 158
     8b2:	fc 4f       	sbci	r31, 0xFC	; 252
     8b4:	60 81       	ld	r22, Z
     8b6:	71 81       	ldd	r23, Z+1	; 0x01
     8b8:	80 e0       	ldi	r24, 0x00	; 0
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     8c0:	20 e0       	ldi	r18, 0x00	; 0
     8c2:	3b e0       	ldi	r19, 0x0B	; 11
     8c4:	4f e3       	ldi	r20, 0x3F	; 63
     8c6:	57 e4       	ldi	r21, 0x47	; 71
     8c8:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     8cc:	18 16       	cp	r1, r24
     8ce:	0c f4       	brge	.+2      	; 0x8d2 <manage_4_BAT+0x4a>
     8d0:	e9 c0       	rjmp	.+466    	; 0xaa4 <manage_4_BAT+0x21c>
     8d2:	ce 01       	movw	r24, r28
     8d4:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     8d8:	bc 01       	movw	r22, r24
     8da:	80 e0       	ldi	r24, 0x00	; 0
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     8e2:	20 e0       	ldi	r18, 0x00	; 0
     8e4:	3b e0       	ldi	r19, 0x0B	; 11
     8e6:	4f e3       	ldi	r20, 0x3F	; 63
     8e8:	57 e4       	ldi	r21, 0x47	; 71
     8ea:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     8ee:	18 16       	cp	r1, r24
     8f0:	3c f0       	brlt	.+14     	; 0x900 <manage_4_BAT+0x78>
     8f2:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     8f6:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 83       	st	Z, r24
     8fe:	d2 c0       	rjmp	.+420    	; 0xaa4 <manage_4_BAT+0x21c>
     900:	20 97       	sbiw	r28, 0x00	; 0
     902:	19 f0       	breq	.+6      	; 0x90a <manage_4_BAT+0x82>
     904:	21 97       	sbiw	r28, 0x01	; 1
     906:	61 f0       	breq	.+24     	; 0x920 <manage_4_BAT+0x98>
     908:	cd c0       	rjmp	.+410    	; 0xaa4 <manage_4_BAT+0x21c>
     90a:	db 9a       	sbi	0x1b, 3	; 27
     90c:	d8 9a       	sbi	0x1b, 0	; 27
     90e:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     912:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	91 83       	std	Z+1, r25	; 0x01
     91c:	80 83       	st	Z, r24
     91e:	c2 c0       	rjmp	.+388    	; 0xaa4 <manage_4_BAT+0x21c>
     920:	d8 98       	cbi	0x1b, 0	; 27
     922:	da 9a       	sbi	0x1b, 2	; 27
     924:	df 9a       	sbi	0x1b, 7	; 27
     926:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     92a:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     92e:	82 e0       	ldi	r24, 0x02	; 2
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	91 83       	std	Z+1, r25	; 0x01
     934:	80 83       	st	Z, r24
     936:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     93a:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     93e:	84 e0       	ldi	r24, 0x04	; 4
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	91 83       	std	Z+1, r25	; 0x01
     944:	80 83       	st	Z, r24
     946:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     94a:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	80 83       	st	Z, r24
     952:	a8 c0       	rjmp	.+336    	; 0xaa4 <manage_4_BAT+0x21c>
     954:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     958:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     95c:	c0 81       	ld	r28, Z
     95e:	d1 81       	ldd	r29, Z+1	; 0x01
     960:	fe 01       	movw	r30, r28
     962:	e3 70       	andi	r30, 0x03	; 3
     964:	ff 27       	eor	r31, r31
     966:	ee 0f       	add	r30, r30
     968:	ff 1f       	adc	r31, r31
     96a:	ee 59       	subi	r30, 0x9E	; 158
     96c:	fc 4f       	sbci	r31, 0xFC	; 252
     96e:	60 81       	ld	r22, Z
     970:	71 81       	ldd	r23, Z+1	; 0x01
     972:	80 e0       	ldi	r24, 0x00	; 0
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	3b e0       	ldi	r19, 0x0B	; 11
     97e:	4f e3       	ldi	r20, 0x3F	; 63
     980:	57 e4       	ldi	r21, 0x47	; 71
     982:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     986:	18 16       	cp	r1, r24
     988:	0c f4       	brge	.+2      	; 0x98c <manage_4_BAT+0x104>
     98a:	6f c0       	rjmp	.+222    	; 0xa6a <manage_4_BAT+0x1e2>
     98c:	ce 01       	movw	r24, r28
     98e:	0e 94 9c 01 	call	0x338	; 0x338 <get_volts_next_bat>
     992:	bc 01       	movw	r22, r24
     994:	80 e0       	ldi	r24, 0x00	; 0
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	3b e0       	ldi	r19, 0x0B	; 11
     9a0:	4f e3       	ldi	r20, 0x3F	; 63
     9a2:	57 e4       	ldi	r21, 0x47	; 71
     9a4:	0e 94 49 11 	call	0x2292	; 0x2292 <__cmpsf2>
     9a8:	18 16       	cp	r1, r24
     9aa:	3c f0       	brlt	.+14     	; 0x9ba <manage_4_BAT+0x132>
     9ac:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     9b0:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	80 83       	st	Z, r24
     9b8:	75 c0       	rjmp	.+234    	; 0xaa4 <manage_4_BAT+0x21c>
     9ba:	c1 30       	cpi	r28, 0x01	; 1
     9bc:	d1 05       	cpc	r29, r1
     9be:	d9 f0       	breq	.+54     	; 0x9f6 <manage_4_BAT+0x16e>
     9c0:	30 f0       	brcs	.+12     	; 0x9ce <manage_4_BAT+0x146>
     9c2:	c2 30       	cpi	r28, 0x02	; 2
     9c4:	d1 05       	cpc	r29, r1
     9c6:	59 f1       	breq	.+86     	; 0xa1e <manage_4_BAT+0x196>
     9c8:	23 97       	sbiw	r28, 0x03	; 3
     9ca:	e9 f1       	breq	.+122    	; 0xa46 <manage_4_BAT+0x1be>
     9cc:	6b c0       	rjmp	.+214    	; 0xaa4 <manage_4_BAT+0x21c>
     9ce:	db 9a       	sbi	0x1b, 3	; 27
     9d0:	d8 9a       	sbi	0x1b, 0	; 27
     9d2:	dd 9a       	sbi	0x1b, 5	; 27
     9d4:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     9d8:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	91 83       	std	Z+1, r25	; 0x01
     9e2:	80 83       	st	Z, r24
     9e4:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     9e8:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     9ec:	87 e0       	ldi	r24, 0x07	; 7
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	91 83       	std	Z+1, r25	; 0x01
     9f2:	80 83       	st	Z, r24
     9f4:	57 c0       	rjmp	.+174    	; 0xaa4 <manage_4_BAT+0x21c>
     9f6:	d8 98       	cbi	0x1b, 0	; 27
     9f8:	da 9a       	sbi	0x1b, 2	; 27
     9fa:	df 9a       	sbi	0x1b, 7	; 27
     9fc:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     a00:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     a04:	82 e0       	ldi	r24, 0x02	; 2
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	91 83       	std	Z+1, r25	; 0x01
     a0a:	80 83       	st	Z, r24
     a0c:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     a10:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     a14:	84 e0       	ldi	r24, 0x04	; 4
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	91 83       	std	Z+1, r25	; 0x01
     a1a:	80 83       	st	Z, r24
     a1c:	43 c0       	rjmp	.+134    	; 0xaa4 <manage_4_BAT+0x21c>
     a1e:	da 98       	cbi	0x1b, 2	; 27
     a20:	d9 9a       	sbi	0x1b, 1	; 27
     a22:	dc 9a       	sbi	0x1b, 4	; 27
     a24:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     a28:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     a2c:	83 e0       	ldi	r24, 0x03	; 3
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	91 83       	std	Z+1, r25	; 0x01
     a32:	80 83       	st	Z, r24
     a34:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     a38:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     a3c:	85 e0       	ldi	r24, 0x05	; 5
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	91 83       	std	Z+1, r25	; 0x01
     a42:	80 83       	st	Z, r24
     a44:	2f c0       	rjmp	.+94     	; 0xaa4 <manage_4_BAT+0x21c>
     a46:	d9 98       	cbi	0x1b, 1	; 27
     a48:	db 98       	cbi	0x1b, 3	; 27
     a4a:	de 9a       	sbi	0x1b, 6	; 27
     a4c:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     a50:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     a54:	11 82       	std	Z+1, r1	; 0x01
     a56:	10 82       	st	Z, r1
     a58:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     a5c:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     a60:	85 e0       	ldi	r24, 0x05	; 5
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	91 83       	std	Z+1, r25	; 0x01
     a66:	80 83       	st	Z, r24
     a68:	1d c0       	rjmp	.+58     	; 0xaa4 <manage_4_BAT+0x21c>
     a6a:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     a6e:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     a72:	01 90       	ld	r0, Z+
     a74:	f0 81       	ld	r31, Z
     a76:	e0 2d       	mov	r30, r0
     a78:	e3 70       	andi	r30, 0x03	; 3
     a7a:	ff 27       	eor	r31, r31
     a7c:	ee 0f       	add	r30, r30
     a7e:	ff 1f       	adc	r31, r31
     a80:	ee 59       	subi	r30, 0x9E	; 158
     a82:	fc 4f       	sbci	r31, 0xFC	; 252
     a84:	60 81       	ld	r22, Z
     a86:	71 81       	ldd	r23, Z+1	; 0x01
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	0e 94 4e 11 	call	0x229c	; 0x229c <__floatunsisf>
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	32 ee       	ldi	r19, 0xE2	; 226
     a94:	4f e6       	ldi	r20, 0x6F	; 111
     a96:	57 e4       	ldi	r21, 0x47	; 71
     a98:	0e 94 af 11 	call	0x235e	; 0x235e <__gesf2>
     a9c:	88 23       	and	r24, r24
     a9e:	14 f0       	brlt	.+4      	; 0xaa4 <manage_4_BAT+0x21c>
     aa0:	0e 94 55 02 	call	0x4aa	; 0x4aa <stop_chargng_bat>
     aa4:	df 91       	pop	r29
     aa6:	cf 91       	pop	r28
     aa8:	08 95       	ret

00000aaa <energy_management>:
     aaa:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <NUM_BATS>
     aae:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <NUM_BATS+0x1>
     ab2:	80 81       	ld	r24, Z
     ab4:	91 81       	ldd	r25, Z+1	; 0x01
     ab6:	83 30       	cpi	r24, 0x03	; 3
     ab8:	91 05       	cpc	r25, r1
     aba:	41 f0       	breq	.+16     	; 0xacc <energy_management+0x22>
     abc:	84 30       	cpi	r24, 0x04	; 4
     abe:	91 05       	cpc	r25, r1
     ac0:	41 f0       	breq	.+16     	; 0xad2 <energy_management+0x28>
     ac2:	02 97       	sbiw	r24, 0x02	; 2
     ac4:	41 f4       	brne	.+16     	; 0xad6 <energy_management+0x2c>
     ac6:	0e 94 70 02 	call	0x4e0	; 0x4e0 <manage_2_BAT>
     aca:	08 95       	ret
     acc:	0e 94 3e 03 	call	0x67c	; 0x67c <manage_3_BAT>
     ad0:	08 95       	ret
     ad2:	0e 94 44 04 	call	0x888	; 0x888 <manage_4_BAT>
     ad6:	08 95       	ret

00000ad8 <manual_set_active>:
     ad8:	8b b3       	in	r24, 0x1b	; 27
     ada:	80 7f       	andi	r24, 0xF0	; 240
     adc:	8b bb       	out	0x1b, r24	; 27
     ade:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <next_bat_active>
     ae2:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <next_bat_active+0x1>
     ae6:	80 81       	ld	r24, Z
     ae8:	91 81       	ldd	r25, Z+1	; 0x01
     aea:	82 30       	cpi	r24, 0x02	; 2
     aec:	91 05       	cpc	r25, r1
     aee:	f9 f0       	breq	.+62     	; 0xb2e <manual_set_active+0x56>
     af0:	28 f4       	brcc	.+10     	; 0xafc <manual_set_active+0x24>
     af2:	00 97       	sbiw	r24, 0x00	; 0
     af4:	51 f0       	breq	.+20     	; 0xb0a <manual_set_active+0x32>
     af6:	01 97       	sbiw	r24, 0x01	; 1
     af8:	81 f0       	breq	.+32     	; 0xb1a <manual_set_active+0x42>
     afa:	08 95       	ret
     afc:	83 30       	cpi	r24, 0x03	; 3
     afe:	91 05       	cpc	r25, r1
     b00:	01 f1       	breq	.+64     	; 0xb42 <manual_set_active+0x6a>
     b02:	8e 3b       	cpi	r24, 0xBE	; 190
     b04:	9a 4b       	sbci	r25, 0xBA	; 186
     b06:	39 f1       	breq	.+78     	; 0xb56 <manual_set_active+0x7e>
     b08:	08 95       	ret
     b0a:	db 98       	cbi	0x1b, 3	; 27
     b0c:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     b10:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     b14:	11 82       	std	Z+1, r1	; 0x01
     b16:	10 82       	st	Z, r1
     b18:	08 95       	ret
     b1a:	d8 9a       	sbi	0x1b, 0	; 27
     b1c:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     b20:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	91 83       	std	Z+1, r25	; 0x01
     b2a:	80 83       	st	Z, r24
     b2c:	08 95       	ret
     b2e:	da 9a       	sbi	0x1b, 2	; 27
     b30:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     b34:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     b38:	82 e0       	ldi	r24, 0x02	; 2
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	91 83       	std	Z+1, r25	; 0x01
     b3e:	80 83       	st	Z, r24
     b40:	08 95       	ret
     b42:	d9 9a       	sbi	0x1b, 1	; 27
     b44:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     b48:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     b4c:	83 e0       	ldi	r24, 0x03	; 3
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	91 83       	std	Z+1, r25	; 0x01
     b52:	80 83       	st	Z, r24
     b54:	08 95       	ret
     b56:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     b5a:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     b5e:	8e eb       	ldi	r24, 0xBE	; 190
     b60:	9a eb       	ldi	r25, 0xBA	; 186
     b62:	91 83       	std	Z+1, r25	; 0x01
     b64:	80 83       	st	Z, r24
     b66:	08 95       	ret

00000b68 <manual_set_chrgng>:
     b68:	8b b3       	in	r24, 0x1b	; 27
     b6a:	8f 70       	andi	r24, 0x0F	; 15
     b6c:	8b bb       	out	0x1b, r24	; 27
     b6e:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <next_bat_chrgng>
     b72:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <next_bat_chrgng+0x1>
     b76:	80 81       	ld	r24, Z
     b78:	91 81       	ldd	r25, Z+1	; 0x01
     b7a:	86 30       	cpi	r24, 0x06	; 6
     b7c:	91 05       	cpc	r25, r1
     b7e:	11 f1       	breq	.+68     	; 0xbc4 <manual_set_chrgng+0x5c>
     b80:	30 f4       	brcc	.+12     	; 0xb8e <manual_set_chrgng+0x26>
     b82:	84 30       	cpi	r24, 0x04	; 4
     b84:	91 05       	cpc	r25, r1
     b86:	51 f0       	breq	.+20     	; 0xb9c <manual_set_chrgng+0x34>
     b88:	05 97       	sbiw	r24, 0x05	; 5
     b8a:	91 f0       	breq	.+36     	; 0xbb0 <manual_set_chrgng+0x48>
     b8c:	08 95       	ret
     b8e:	87 30       	cpi	r24, 0x07	; 7
     b90:	91 05       	cpc	r25, r1
     b92:	11 f1       	breq	.+68     	; 0xbd8 <manual_set_chrgng+0x70>
     b94:	8e 3b       	cpi	r24, 0xBE	; 190
     b96:	9a 4b       	sbci	r25, 0xBA	; 186
     b98:	49 f1       	breq	.+82     	; 0xbec <manual_set_chrgng+0x84>
     b9a:	08 95       	ret
     b9c:	db 9a       	sbi	0x1b, 3	; 27
     b9e:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     ba2:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     ba6:	84 e0       	ldi	r24, 0x04	; 4
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	91 83       	std	Z+1, r25	; 0x01
     bac:	80 83       	st	Z, r24
     bae:	08 95       	ret
     bb0:	dc 9a       	sbi	0x1b, 4	; 27
     bb2:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     bb6:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     bba:	85 e0       	ldi	r24, 0x05	; 5
     bbc:	90 e0       	ldi	r25, 0x00	; 0
     bbe:	91 83       	std	Z+1, r25	; 0x01
     bc0:	80 83       	st	Z, r24
     bc2:	08 95       	ret
     bc4:	de 9a       	sbi	0x1b, 6	; 27
     bc6:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     bca:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     bce:	86 e0       	ldi	r24, 0x06	; 6
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	91 83       	std	Z+1, r25	; 0x01
     bd4:	80 83       	st	Z, r24
     bd6:	08 95       	ret
     bd8:	dd 9a       	sbi	0x1b, 5	; 27
     bda:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     bde:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     be2:	87 e0       	ldi	r24, 0x07	; 7
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	91 83       	std	Z+1, r25	; 0x01
     be8:	80 83       	st	Z, r24
     bea:	08 95       	ret
     bec:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     bf0:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     bf4:	8e eb       	ldi	r24, 0xBE	; 190
     bf6:	9a eb       	ldi	r25, 0xBA	; 186
     bf8:	91 83       	std	Z+1, r25	; 0x01
     bfa:	80 83       	st	Z, r24
     bfc:	08 95       	ret

00000bfe <mode_settings_init>:
}

void mode_settings_init(void)
{
	/* ---------- Set status flags for the battery management ---------- */
	*bat_active = STAT_ACT_B0;				// Bat 3 is active on default
     bfe:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <bat_active>
     c02:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <bat_active+0x1>
     c06:	11 82       	std	Z+1, r1	; 0x01
     c08:	10 82       	st	Z, r1
	*bat_chrgng = STAT_CHRG_NONE;			// No battery charging
     c0a:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <bat_chrgng>
     c0e:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <bat_chrgng+0x1>
     c12:	8e eb       	ldi	r24, 0xBE	; 190
     c14:	9a eb       	ldi	r25, 0xBA	; 186
     c16:	91 83       	std	Z+1, r25	; 0x01
     c18:	80 83       	st	Z, r24
	
	/* --- Set the holding registers for settings --- */
	*MANUAL_MODE	   = false;				// usRegHoldingBuf[0] = false;				// MANUAL_MODE
     c1a:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <MANUAL_MODE>
     c1e:	f0 91 0f 01 	lds	r31, 0x010F	; 0x80010f <MANUAL_MODE+0x1>
     c22:	10 82       	st	Z, r1
	usRegHoldingBuf[1] = NUM_2_BAT;			// NUM_BATs
     c24:	e0 e5       	ldi	r30, 0x50	; 80
     c26:	f3 e0       	ldi	r31, 0x03	; 3
     c28:	22 e0       	ldi	r18, 0x02	; 2
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	33 83       	std	Z+3, r19	; 0x03
     c2e:	22 83       	std	Z+2, r18	; 0x02
	usRegHoldingBuf[2] = BAT_CELLS;			// BAT_CELLS
     c30:	35 83       	std	Z+5, r19	; 0x05
     c32:	24 83       	std	Z+4, r18	; 0x04
	usRegHoldingBuf[3] = STAT_ACT_B0;		// ACTIVE_BAT
     c34:	17 82       	std	Z+7, r1	; 0x07
     c36:	16 82       	std	Z+6, r1	; 0x06
	usRegHoldingBuf[4] = STAT_CHRG_NONE;	// CHRGNG_BAT
     c38:	91 87       	std	Z+9, r25	; 0x09
     c3a:	80 87       	std	Z+8, r24	; 0x08
	*WIRELESS_MODE	   = false;					// usRegHoldingBuf[5] = false;				// COMM_MODE
     c3c:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <WIRELESS_MODE>
     c40:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <WIRELESS_MODE+0x1>
     c44:	10 82       	st	Z, r1
	*NEW_SETTINGS	   = false;					// usRegHoldingBuf[6] = false;				// NEW_SETTINGS
     c46:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <NEW_SETTINGS>
     c4a:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <NEW_SETTINGS+0x1>
     c4e:	10 82       	st	Z, r1
	*CHRG_CYCLE		   = false;					// usRegHoldingBuf[7] = false;				// CHRG_CYCLE active?		
     c50:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <CHRG_CYCLE>
     c54:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <CHRG_CYCLE+0x1>
     c58:	10 82       	st	Z, r1
	*EMERGENCY_STOP	   = false;				// usRegHoldingBuf[8] = false;				// EMERGENCY_STOP active?
     c5a:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     c5e:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     c62:	10 82       	st	Z, r1
     c64:	08 95       	ret

00000c66 <timer_init>:

/*
 * Initializes timer registers (TIMER 0 8-Bit). 
 */
void timer_init(void){
	TIMSK = (1 << TOIE0);
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	87 bf       	out	0x37, r24	; 55
	// Prescaler of 1024: 	t_interval = ( 2^8 * 1024 ) / 7372800 = 0.036s
	TCCR0 = ( (1 << CS01) | (1 << CS01) | (1 << CS00) );
     c6a:	83 e0       	ldi	r24, 0x03	; 3
     c6c:	83 bf       	out	0x33, r24	; 51
	TCNT0 = 0;
     c6e:	12 be       	out	0x32, r1	; 50
	adc_timer_ovf_cnt = 0;
     c70:	10 92 b8 06 	sts	0x06B8, r1	; 0x8006b8 <adc_timer_ovf_cnt>
	wimod_timer_ovf_cnt = 0;
     c74:	10 92 ba 06 	sts	0x06BA, r1	; 0x8006ba <wimod_timer_ovf_cnt+0x1>
     c78:	10 92 b9 06 	sts	0x06B9, r1	; 0x8006b9 <wimod_timer_ovf_cnt>
     c7c:	08 95       	ret

00000c7e <ctrl_pin_init>:
/*
 * Initializes output pins used in the management routines. 
 */
void ctrl_pin_init(void) {
	// Set pins PA0...PA7 as OUTPUT in GPIO Register A
	DDRA |=  ( (1 << PA7) | (1 << PA6) | (1 << PA5) | (1 << PA4)  | (1 << PA3) | (1 << PA2) | (1 << PA1) | (1 << PA0) );
     c7e:	8a b3       	in	r24, 0x1a	; 26
     c80:	8f ef       	ldi	r24, 0xFF	; 255
     c82:	8a bb       	out	0x1a, r24	; 26
	// Set all pins to zero in PORTA
	PORTA &= ~ ( (1 << PA7) | (1 << PA6) | (1 << PA5) | (1 << PA4)  | (1 << PA3) | (1 << PA2) | (1 << PA1) | (1 << PA0) );
     c84:	8b b3       	in	r24, 0x1b	; 27
     c86:	1b ba       	out	0x1b, r1	; 27
     c88:	08 95       	ret

00000c8a <config_lora_module>:
/*
 * Configure the LoRa wireless module. 
 * 
 * Only settings that are changed are the Group Addr. and Device Addr.
 */
void config_lora_module(void){
     c8a:	cf 93       	push	r28
     c8c:	df 93       	push	r29
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
     c92:	c2 53       	subi	r28, 0x32	; 50
     c94:	d1 40       	sbci	r29, 0x01	; 1
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	de bf       	out	0x3e, r29	; 62
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	cd bf       	out	0x3d, r28	; 61
	TWiMOD_HCI_Message configMsg;
	configMsg.SapID = DEVMGMT_ID;								// 0x01
     ca0:	31 e0       	ldi	r19, 0x01	; 1
     ca2:	3b 83       	std	Y+3, r19	; 0x03
	configMsg.MsgID = DEVMGMT_MSG_SET_RADIO_CONFIG_REQ;			// 0x11
     ca4:	81 e1       	ldi	r24, 0x11	; 17
     ca6:	8c 83       	std	Y+4, r24	; 0x04
	
	/* --------------- Payload -------------- */
	configMsg.Payload[0] = 0x00;		// Store NVM Flag
     ca8:	1d 82       	std	Y+5, r1	; 0x05
	/* ---------- Radio Configuration Field ---------- */
	configMsg.Payload[1] = 0x00;						// Radio Mode
     caa:	1e 82       	std	Y+6, r1	; 0x06
	configMsg.Payload[2] = 0x25;						// Group Address
     cac:	95 e2       	ldi	r25, 0x25	; 37
     cae:	9f 83       	std	Y+7, r25	; 0x07
	configMsg.Payload[3] = 0x25;						// Tx Group Address
     cb0:	98 87       	std	Y+8, r25	; 0x08
	configMsg.Payload[4] = 0x11;						// Device Address [low-byte]
     cb2:	89 87       	std	Y+9, r24	; 0x09
	configMsg.Payload[5] = 0x47;						// Device Address [high-byte]
     cb4:	97 e4       	ldi	r25, 0x47	; 71
     cb6:	9a 87       	std	Y+10, r25	; 0x0a
	configMsg.Payload[6] = 0x11;						// Tx Device Address [low-byte]
     cb8:	8b 87       	std	Y+11, r24	; 0x0b
	configMsg.Payload[7] = 0x47;						// Tx Device Address [high-byte]
     cba:	9c 87       	std	Y+12, r25	; 0x0c
	configMsg.Payload[8] = 0x00;						// Modulation: 0x00 == LoRa
     cbc:	1d 86       	std	Y+13, r1	; 0x0d
	configMsg.Payload[9] = 0x99;						// RF Carrier Frequency [least significant bits]
     cbe:	99 e9       	ldi	r25, 0x99	; 153
     cc0:	9e 87       	std	Y+14, r25	; 0x0e
	configMsg.Payload[10] = 0x61;						// RF Carrier Frequency [intermediate bits]
     cc2:	91 e6       	ldi	r25, 0x61	; 97
     cc4:	9f 87       	std	Y+15, r25	; 0x0f
	configMsg.Payload[11] = 0xd9;						// RF Carrier Frequency [most significant bits]
     cc6:	99 ed       	ldi	r25, 0xD9	; 217
     cc8:	98 8b       	std	Y+16, r25	; 0x10
	configMsg.Payload[12] = 0x00;						// LoRa Signal Bandwidth
     cca:	19 8a       	std	Y+17, r1	; 0x11
	configMsg.Payload[13] = 0x0b;						// LoRa Spreading Factor
     ccc:	2b e0       	ldi	r18, 0x0B	; 11
     cce:	2a 8b       	std	Y+18, r18	; 0x12
	configMsg.Payload[14] = 0x02;						// Error Coding
     cd0:	92 e0       	ldi	r25, 0x02	; 2
     cd2:	9b 8b       	std	Y+19, r25	; 0x13
	configMsg.Payload[15] = 0x11;						// Power level
     cd4:	8c 8b       	std	Y+20, r24	; 0x14
	configMsg.Payload[16] = 0x00;						// Tx control
     cd6:	1d 8a       	std	Y+21, r1	; 0x15
	configMsg.Payload[17] = 0x01;						// Rx control
     cd8:	3e 8b       	std	Y+22, r19	; 0x16
	configMsg.Payload[18] = 0xb8;						// Rx window time [low byte]
     cda:	88 eb       	ldi	r24, 0xB8	; 184
     cdc:	8f 8b       	std	Y+23, r24	; 0x17
	configMsg.Payload[19] = 0x0b;						// Rx window time [high byte]
     cde:	28 8f       	std	Y+24, r18	; 0x18
	configMsg.Payload[20] = 0x07;						// LED control
     ce0:	87 e0       	ldi	r24, 0x07	; 7
     ce2:	89 8f       	std	Y+25, r24	; 0x19
	configMsg.Payload[21] = 0x03;						// Misc. Options
     ce4:	83 e0       	ldi	r24, 0x03	; 3
     ce6:	8a 8f       	std	Y+26, r24	; 0x1a
	configMsg.Payload[22] = 0x02;						// FSK Datarate
     ce8:	9b 8f       	std	Y+27, r25	; 0x1b
	configMsg.Payload[23] = 0x00;						// Automatic Power Saving
     cea:	1c 8e       	std	Y+28, r1	; 0x1c
	configMsg.Payload[24] = 0x00;						// LBT Threshold [low-byte]
     cec:	1d 8e       	std	Y+29, r1	; 0x1d
	configMsg.Payload[25] = 0x00;						// LBT Threshold [high-byte]
     cee:	1e 8e       	std	Y+30, r1	; 0x1e
	/* ------------ Length ------------ */
	configMsg.Length = 1 + 25;
     cf0:	8a e1       	ldi	r24, 0x1A	; 26
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	9a 83       	std	Y+2, r25	; 0x02
     cf6:	89 83       	std	Y+1, r24	; 0x01

	WiMOD_HCI_SendMessage(&configMsg);
     cf8:	ce 01       	movw	r24, r28
     cfa:	01 96       	adiw	r24, 0x01	; 1
     cfc:	0e 94 9d 10 	call	0x213a	; 0x213a <WiMOD_HCI_SendMessage>
	/*memset(&configMsg, 0, sizeof(TWiMOD_HCI_Message));
	configMsg.SapID = 0x01;			// DEVMGMT_ID
	configMsg.MsgID = 0x13;			// DEVMGMT_MSG_GET_RADIO_CONFIG_REQ
	configMsg.Length = 0;
	WiMOD_HCI_SendMessage(&configMsg);*/
}
     d00:	ce 5c       	subi	r28, 0xCE	; 206
     d02:	de 4f       	sbci	r29, 0xFE	; 254
     d04:	0f b6       	in	r0, 0x3f	; 63
     d06:	f8 94       	cli
     d08:	de bf       	out	0x3e, r29	; 62
     d0a:	0f be       	out	0x3f, r0	; 63
     d0c:	cd bf       	out	0x3d, r28	; 61
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	08 95       	ret

00000d14 <init_all>:

/*
 * Central initialization method
 */
void init_all(){
     d14:	ef 92       	push	r14
     d16:	0f 93       	push	r16
     d18:	1f 93       	push	r17
	cli();
     d1a:	f8 94       	cli
	
	ctrl_pin_init();
     d1c:	0e 94 3f 06 	call	0xc7e	; 0xc7e <ctrl_pin_init>
	
	// ONLY FOR TESTING PURPOSES (wimod interface) -- Normally claimed by MODBUS
	//uart0_init(7); //115200 8N1 -- USB
	
	uart1_init(7); //115200 8N1 -- WiMOD
     d20:	87 e0       	ldi	r24, 0x07	; 7
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <uart1_init>
	
	spi_init();
     d28:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <spi_init>
	
	/* ---------- Initialize Timer ---------- */
	timer_init();
     d2c:	0e 94 33 06 	call	0xc66	; 0xc66 <timer_init>
	
	mode_settings_init();
     d30:	0e 94 ff 05 	call	0xbfe	; 0xbfe <mode_settings_init>
		
	/* ---------- Make an initial fetch of ADC values ---------- */
	fetch_adc_values( );
     d34:	0e 94 65 01 	call	0x2ca	; 0x2ca <fetch_adc_values>

	
	const char _BLANK = "BLANK";
	WiMOD_HCI_Init(_BLANK, wimod_rx_callback, &rxMessage);
     d38:	4b eb       	ldi	r20, 0xBB	; 187
     d3a:	56 e0       	ldi	r21, 0x06	; 6
     d3c:	6f e0       	ldi	r22, 0x0F	; 15
     d3e:	71 e1       	ldi	r23, 0x11	; 17
     d40:	86 e4       	ldi	r24, 0x46	; 70
     d42:	91 e0       	ldi	r25, 0x01	; 1
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	0e 94 83 10 	call	0x2106	; 0x2106 <WiMOD_HCI_Init>


	/* ---------- MODBUS initialization as AVR/port/demo.c ---------- */
    eStatus = eMBInit( MB_MODE, SLAVE_ADDRESS, PORT, BAUDRATRE, PARITY );
     d4a:	e1 2c       	mov	r14, r1
     d4c:	00 e0       	ldi	r16, 0x00	; 0
     d4e:	12 ec       	ldi	r17, 0xC2	; 194
     d50:	21 e0       	ldi	r18, 0x01	; 1
     d52:	30 e0       	ldi	r19, 0x00	; 0
     d54:	40 e0       	ldi	r20, 0x00	; 0
     d56:	6a e0       	ldi	r22, 0x0A	; 10
     d58:	80 e0       	ldi	r24, 0x00	; 0
     d5a:	0e 94 18 0b 	call	0x1630	; 0x1630 <eMBInit>
     d5e:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <eStatus>

    eStatus = eMBSetSlaveID( 0x34, TRUE, ucSlaveID, 3 );
     d62:	23 e0       	ldi	r18, 0x03	; 3
     d64:	30 e0       	ldi	r19, 0x00	; 0
     d66:	4c e4       	ldi	r20, 0x4C	; 76
     d68:	51 e0       	ldi	r21, 0x01	; 1
     d6a:	61 e0       	ldi	r22, 0x01	; 1
     d6c:	84 e3       	ldi	r24, 0x34	; 52
     d6e:	0e 94 c6 0a 	call	0x158c	; 0x158c <eMBSetSlaveID>
     d72:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <eStatus>
    //sei(  );

    /* Enable the MODBUS Protocol Stack. */
    eStatus = eMBEnable(  );
     d76:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <eMBEnable>
     d7a:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <eStatus>
	/* ---------- AVR/port/demo.c definitions ---------- */ 
	sei();
     d7e:	78 94       	sei
	
	//config_lora_module( );
	
}
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ef 90       	pop	r14
     d86:	08 95       	ret

00000d88 <main>:
 */
int main(void)
{

    /* Initialize routine.. */
	init_all();
     d88:	0e 94 8a 06 	call	0xd14	; 0xd14 <init_all>
	
	//some_testing_stuff( ); 
	//send_system_info_radio();
	

	config_lora_module();
     d8c:	0e 94 45 06 	call	0xc8a	; 0xc8a <config_lora_module>
			/*	Responsibility lays in the hands of the experiment conductor.								*/
			/************************************************************************************************/
				
			*EMERGENCY_STOP = false;
		}else{
			*EMERGENCY_STOP = true;
     d90:	c1 e0       	ldi	r28, 0x01	; 1
	config_lora_module();

	while(1)
	{
		/* ---- Check whether batteries are ok. ---- */
		if(assert_bats_ok( )){		// if not break the control loop.
     d92:	0e 94 db 01 	call	0x3b6	; 0x3b6 <assert_bats_ok>
     d96:	88 23       	and	r24, r24
     d98:	31 f0       	breq	.+12     	; 0xda6 <main+0x1e>
			/*	connection!!! But This doesn't work as the MOSFET for Bat0 would be automatically switched  */
			/*	back on on power loss!!!																	*/
			/*	Responsibility lays in the hands of the experiment conductor.								*/
			/************************************************************************************************/
				
			*EMERGENCY_STOP = false;
     d9a:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     d9e:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     da2:	10 82       	st	Z, r1
     da4:	05 c0       	rjmp	.+10     	; 0xdb0 <main+0x28>
		}else{
			*EMERGENCY_STOP = true;
     da6:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     daa:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     dae:	c0 83       	st	Z, r28
		}

		cli();
     db0:	f8 94       	cli
		// Every 1s -- Fetch system data and do energy management
		if(adc_timer_ovf_cnt == ADC_TIMER_OVF_FACTOR)
     db2:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <adc_timer_ovf_cnt>
     db6:	8c 31       	cpi	r24, 0x1C	; 28
     db8:	21 f4       	brne	.+8      	; 0xdc2 <main+0x3a>
		{		
			// Reset overflow counter
			adc_timer_ovf_cnt = 0;
     dba:	10 92 b8 06 	sts	0x06B8, r1	; 0x8006b8 <adc_timer_ovf_cnt>

			// Update ADC values
			fetch_adc_values( );
     dbe:	0e 94 65 01 	call	0x2ca	; 0x2ca <fetch_adc_values>
// 					energy_management( );
// 				}

					
		}
		sei();
     dc2:	78 94       	sei

			
		cli();
     dc4:	f8 94       	cli
		if(wimod_timer_ovf_cnt == WIMOD_TIMER_OVF_FACTOR)
     dc6:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <wimod_timer_ovf_cnt>
     dca:	90 91 ba 06 	lds	r25, 0x06BA	; 0x8006ba <wimod_timer_ovf_cnt+0x1>
     dce:	80 3e       	cpi	r24, 0xE0	; 224
     dd0:	91 05       	cpc	r25, r1
     dd2:	31 f4       	brne	.+12     	; 0xde0 <main+0x58>
		{
			wimod_timer_ovf_cnt = 0;
     dd4:	10 92 ba 06 	sts	0x06BA, r1	; 0x8006ba <wimod_timer_ovf_cnt+0x1>
     dd8:	10 92 b9 06 	sts	0x06B9, r1	; 0x8006b9 <wimod_timer_ovf_cnt>
				
			send_system_info_radio();	
     ddc:	0e 94 da 10 	call	0x21b4	; 0x21b4 <send_system_info_radio>
		}
		sei();
     de0:	78 94       	sei
			( void )eMBPoll( );
		}
		*/
			
		// .. or the MODBUS 
		( void )eMBPoll( );
     de2:	0e 94 8a 0b 	call	0x1714	; 0x1714 <eMBPoll>

 		if(*EMERGENCY_STOP == false && *MANUAL_MODE == false)
     de6:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <EMERGENCY_STOP>
     dea:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <EMERGENCY_STOP+0x1>
     dee:	80 81       	ld	r24, Z
     df0:	81 11       	cpse	r24, r1
     df2:	0a c0       	rjmp	.+20     	; 0xe08 <main+0x80>
     df4:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <MANUAL_MODE>
     df8:	f0 91 0f 01 	lds	r31, 0x010F	; 0x80010f <MANUAL_MODE+0x1>
     dfc:	80 81       	ld	r24, Z
     dfe:	81 11       	cpse	r24, r1
     e00:	0b c0       	rjmp	.+22     	; 0xe18 <main+0x90>
 		{
 			energy_management( );
     e02:	0e 94 55 05 	call	0xaaa	; 0xaaa <energy_management>
     e06:	c5 cf       	rjmp	.-118    	; 0xd92 <main+0xa>
		}
		else if(*MANUAL_MODE && *NEW_SETTINGS)
     e08:	e0 91 0e 01 	lds	r30, 0x010E	; 0x80010e <MANUAL_MODE>
     e0c:	f0 91 0f 01 	lds	r31, 0x010F	; 0x80010f <MANUAL_MODE+0x1>
     e10:	80 81       	ld	r24, Z
     e12:	88 23       	and	r24, r24
     e14:	09 f4       	brne	.+2      	; 0xe18 <main+0x90>
     e16:	bd cf       	rjmp	.-134    	; 0xd92 <main+0xa>
     e18:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <NEW_SETTINGS>
     e1c:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <NEW_SETTINGS+0x1>
     e20:	80 81       	ld	r24, Z
     e22:	88 23       	and	r24, r24
     e24:	09 f4       	brne	.+2      	; 0xe28 <main+0xa0>
     e26:	b5 cf       	rjmp	.-150    	; 0xd92 <main+0xa>
		{
			// Activate new settings fetched from holding registers...
			manual_set_active();
     e28:	0e 94 6c 05 	call	0xad8	; 0xad8 <manual_set_active>
			manual_set_chrgng();
     e2c:	0e 94 b4 05 	call	0xb68	; 0xb68 <manual_set_chrgng>
				
			*NEW_SETTINGS = false;
     e30:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <NEW_SETTINGS>
     e34:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <NEW_SETTINGS+0x1>
     e38:	10 82       	st	Z, r1
     e3a:	ab cf       	rjmp	.-170    	; 0xd92 <main+0xa>

00000e3c <eMBRegInputCB>:
/*
 * Callback for the Input Registers in the MODBUS.
 */
eMBErrorCode
eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
    eMBErrorCode    eStatus = MB_ENOERR;
    int             iRegIndex;

    if( ( usAddress >= REG_INPUT_START )
     e40:	60 33       	cpi	r22, 0x30	; 48
     e42:	25 e7       	ldi	r18, 0x75	; 117
     e44:	72 07       	cpc	r23, r18
     e46:	08 f1       	brcs	.+66     	; 0xe8a <eMBRegInputCB+0x4e>
        && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
     e48:	9b 01       	movw	r18, r22
     e4a:	24 0f       	add	r18, r20
     e4c:	35 1f       	adc	r19, r21
     e4e:	2b 33       	cpi	r18, 0x3B	; 59
     e50:	35 47       	sbci	r19, 0x75	; 117
     e52:	e8 f4       	brcc	.+58     	; 0xe8e <eMBRegInputCB+0x52>
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        while( usNRegs > 0 )
     e54:	41 15       	cp	r20, r1
     e56:	51 05       	cpc	r21, r1
     e58:	e1 f0       	breq	.+56     	; 0xe92 <eMBRegInputCB+0x56>
     e5a:	fc 01       	movw	r30, r24
     e5c:	66 0f       	add	r22, r22
     e5e:	77 1f       	adc	r23, r23
     e60:	db 01       	movw	r26, r22
     e62:	ae 5f       	subi	r26, 0xFE	; 254
     e64:	b6 4e       	sbci	r27, 0xE6	; 230
     e66:	44 0f       	add	r20, r20
     e68:	55 1f       	adc	r21, r21
     e6a:	48 0f       	add	r20, r24
     e6c:	59 1f       	adc	r21, r25
     e6e:	ed 01       	movw	r28, r26
        {
            *pucRegBuffer++ =
     e70:	11 96       	adiw	r26, 0x01	; 1
     e72:	9c 91       	ld	r25, X
     e74:	11 97       	sbiw	r26, 0x01	; 1
     e76:	90 83       	st	Z, r25
                ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
            *pucRegBuffer++ =
     e78:	98 81       	ld	r25, Y
     e7a:	12 96       	adiw	r26, 0x02	; 2
     e7c:	91 83       	std	Z+1, r25	; 0x01
     e7e:	32 96       	adiw	r30, 0x02	; 2

    if( ( usAddress >= REG_INPUT_START )
        && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        while( usNRegs > 0 )
     e80:	e4 17       	cp	r30, r20
     e82:	f5 07       	cpc	r31, r21
     e84:	a1 f7       	brne	.-24     	; 0xe6e <eMBRegInputCB+0x32>
 * Callback for the Input Registers in the MODBUS.
 */
eMBErrorCode
eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    eMBErrorCode    eStatus = MB_ENOERR;
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	05 c0       	rjmp	.+10     	; 0xe94 <eMBRegInputCB+0x58>
            usNRegs--;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
     e8a:	81 e0       	ldi	r24, 0x01	; 1
     e8c:	03 c0       	rjmp	.+6      	; 0xe94 <eMBRegInputCB+0x58>
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	01 c0       	rjmp	.+2      	; 0xe94 <eMBRegInputCB+0x58>
 * Callback for the Input Registers in the MODBUS.
 */
eMBErrorCode
eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    eMBErrorCode    eStatus = MB_ENOERR;
     e92:	80 e0       	ldi	r24, 0x00	; 0


	/* Trigger the WiMOD transmission here too. */

    return eStatus;
}
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	08 95       	ret

00000e9a <eMBRegHoldingCB>:


eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
     e9a:	cf 93       	push	r28
     e9c:	df 93       	push	r29
	eMBErrorCode    eStatus = MB_ENOERR;
    int             iRegIndex;
	
	switch(eMode){
     e9e:	22 23       	and	r18, r18
     ea0:	19 f0       	breq	.+6      	; 0xea8 <eMBRegHoldingCB+0xe>
     ea2:	21 30       	cpi	r18, 0x01	; 1
     ea4:	41 f1       	breq	.+80     	; 0xef6 <eMBRegHoldingCB+0x5c>
     ea6:	56 c0       	rjmp	.+172    	; 0xf54 <eMBRegHoldingCB+0xba>
		case MB_REG_READ:
		// On read just return the holding registers same procedure as for Input registers (copy-paste).
			if( ( usAddress >= REG_HOLDING_START )
     ea8:	60 34       	cpi	r22, 0x40	; 64
     eaa:	2c e9       	ldi	r18, 0x9C	; 156
     eac:	72 07       	cpc	r23, r18
     eae:	08 f4       	brcc	.+2      	; 0xeb2 <eMBRegHoldingCB+0x18>
     eb0:	53 c0       	rjmp	.+166    	; 0xf58 <eMBRegHoldingCB+0xbe>
				&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
     eb2:	9b 01       	movw	r18, r22
     eb4:	24 0f       	add	r18, r20
     eb6:	35 1f       	adc	r19, r21
     eb8:	2a 34       	cpi	r18, 0x4A	; 74
     eba:	3c 49       	sbci	r19, 0x9C	; 156
     ebc:	08 f0       	brcs	.+2      	; 0xec0 <eMBRegHoldingCB+0x26>
     ebe:	4e c0       	rjmp	.+156    	; 0xf5c <eMBRegHoldingCB+0xc2>
			{
				iRegIndex = ( int )( usAddress - usRegHoldingStart );
				while( usNRegs > 0 )
     ec0:	41 15       	cp	r20, r1
     ec2:	51 05       	cpc	r21, r1
     ec4:	09 f4       	brne	.+2      	; 0xec8 <eMBRegHoldingCB+0x2e>
     ec6:	4c c0       	rjmp	.+152    	; 0xf60 <eMBRegHoldingCB+0xc6>
     ec8:	dc 01       	movw	r26, r24
     eca:	fb 01       	movw	r30, r22
     ecc:	ee 0f       	add	r30, r30
     ece:	ff 1f       	adc	r31, r31
     ed0:	e0 53       	subi	r30, 0x30	; 48
     ed2:	f5 43       	sbci	r31, 0x35	; 53
     ed4:	44 0f       	add	r20, r20
     ed6:	55 1f       	adc	r21, r21
     ed8:	48 0f       	add	r20, r24
     eda:	59 1f       	adc	r21, r25
				{
					*pucRegBuffer++ =
     edc:	91 81       	ldd	r25, Z+1	; 0x01
     ede:	9c 93       	st	X, r25
						( unsigned char )( usRegHoldingBuf[iRegIndex] >> 8 );
					*pucRegBuffer++ =
     ee0:	90 81       	ld	r25, Z
     ee2:	32 96       	adiw	r30, 0x02	; 2
     ee4:	11 96       	adiw	r26, 0x01	; 1
     ee6:	9c 93       	st	X, r25
     ee8:	11 97       	sbiw	r26, 0x01	; 1
     eea:	12 96       	adiw	r26, 0x02	; 2
		// On read just return the holding registers same procedure as for Input registers (copy-paste).
			if( ( usAddress >= REG_HOLDING_START )
				&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
			{
				iRegIndex = ( int )( usAddress - usRegHoldingStart );
				while( usNRegs > 0 )
     eec:	a4 17       	cp	r26, r20
     eee:	b5 07       	cpc	r27, r21
     ef0:	a9 f7       	brne	.-22     	; 0xedc <eMBRegHoldingCB+0x42>

eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
	eMBErrorCode    eStatus = MB_ENOERR;
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	3a c0       	rjmp	.+116    	; 0xf6a <eMBRegHoldingCB+0xd0>
		
		break;
		case MB_REG_WRITE:
		// On Write set the holding registers to new values and in case of manual mode set
		// active and charging bat accordingly
			if( ( usAddress >= REG_HOLDING_START )
     ef6:	60 34       	cpi	r22, 0x40	; 64
     ef8:	2c e9       	ldi	r18, 0x9C	; 156
     efa:	72 07       	cpc	r23, r18
     efc:	98 f1       	brcs	.+102    	; 0xf64 <eMBRegHoldingCB+0xca>
				&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
     efe:	9b 01       	movw	r18, r22
     f00:	24 0f       	add	r18, r20
     f02:	35 1f       	adc	r19, r21
     f04:	2a 34       	cpi	r18, 0x4A	; 74
     f06:	3c 49       	sbci	r19, 0x9C	; 156
     f08:	78 f5       	brcc	.+94     	; 0xf68 <eMBRegHoldingCB+0xce>
			{
				iRegIndex = ( int )( usAddress - usRegHoldingStart );
				while( usNRegs > 0 )
     f0a:	41 15       	cp	r20, r1
     f0c:	51 05       	cpc	r21, r1
     f0e:	d1 f0       	breq	.+52     	; 0xf44 <eMBRegHoldingCB+0xaa>
     f10:	dc 01       	movw	r26, r24
     f12:	fb 01       	movw	r30, r22
     f14:	ee 0f       	add	r30, r30
     f16:	ff 1f       	adc	r31, r31
     f18:	e0 53       	subi	r30, 0x30	; 48
     f1a:	f5 43       	sbci	r31, 0x35	; 53
     f1c:	44 0f       	add	r20, r20
     f1e:	55 1f       	adc	r21, r21
     f20:	84 0f       	add	r24, r20
     f22:	95 1f       	adc	r25, r21
				{
					usRegHoldingBuf[iRegIndex] = 
						( unsigned short ) ( *pucRegBuffer++ << 8 );
     f24:	2c 91       	ld	r18, X
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	32 2f       	mov	r19, r18
     f2a:	22 27       	eor	r18, r18
				&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
			{
				iRegIndex = ( int )( usAddress - usRegHoldingStart );
				while( usNRegs > 0 )
				{
					usRegHoldingBuf[iRegIndex] = 
     f2c:	31 83       	std	Z+1, r19	; 0x01
     f2e:	20 83       	st	Z, r18
						( unsigned short ) ( *pucRegBuffer++ << 8 );
					usRegHoldingBuf[iRegIndex] |= ( unsigned short ) *pucRegBuffer++;
     f30:	11 96       	adiw	r26, 0x01	; 1
     f32:	4c 91       	ld	r20, X
     f34:	11 97       	sbiw	r26, 0x01	; 1
     f36:	24 2b       	or	r18, r20
     f38:	21 93       	st	Z+, r18
     f3a:	31 93       	st	Z+, r19
     f3c:	12 96       	adiw	r26, 0x02	; 2
		// active and charging bat accordingly
			if( ( usAddress >= REG_HOLDING_START )
				&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
			{
				iRegIndex = ( int )( usAddress - usRegHoldingStart );
				while( usNRegs > 0 )
     f3e:	a8 17       	cp	r26, r24
     f40:	b9 07       	cpc	r27, r25
     f42:	81 f7       	brne	.-32     	; 0xf24 <eMBRegHoldingCB+0x8a>
				/* ---
 
					Indicate new settings..
					
				--- */
				*NEW_SETTINGS = true;
     f44:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <NEW_SETTINGS>
     f48:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <NEW_SETTINGS+0x1>
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	80 83       	st	Z, r24

eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
	eMBErrorCode    eStatus = MB_ENOERR;
     f50:	80 e0       	ldi	r24, 0x00	; 0
				/* ---
 
					Indicate new settings..
					
				--- */
				*NEW_SETTINGS = true;
     f52:	0b c0       	rjmp	.+22     	; 0xf6a <eMBRegHoldingCB+0xd0>

eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
	eMBErrorCode    eStatus = MB_ENOERR;
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	09 c0       	rjmp	.+18     	; 0xf6a <eMBRegHoldingCB+0xd0>
					usNRegs--;
				}
			}
			else
			{
				eStatus = MB_ENOREG;
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	07 c0       	rjmp	.+14     	; 0xf6a <eMBRegHoldingCB+0xd0>
     f5c:	81 e0       	ldi	r24, 0x01	; 1
     f5e:	05 c0       	rjmp	.+10     	; 0xf6a <eMBRegHoldingCB+0xd0>

eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
	eMBErrorCode    eStatus = MB_ENOERR;
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	03 c0       	rjmp	.+6      	; 0xf6a <eMBRegHoldingCB+0xd0>
				--- */
				*NEW_SETTINGS = true;
			}
			else
			{
				eStatus = MB_ENOREG;
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <eMBRegHoldingCB+0xd0>
     f68:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
	
	// Holding registers have to be updated anytime the management routines do alterations.
    return eStatus;
}
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	08 95       	ret

00000f70 <eMBRegDiscreteCB>:

eMBErrorCode
eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    return MB_ENOREG;
}
     f70:	81 e0       	ldi	r24, 0x01	; 1
     f72:	08 95       	ret

00000f74 <eMBRegCoilsCB>:
eMBErrorCode
eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils,
               eMBRegisterMode eMode )
{
    return MB_ENOREG;
}
     f74:	81 e0       	ldi	r24, 0x01	; 1
     f76:	08 95       	ret

00000f78 <__vector_16>:

/************************************************************************/
/* Interrupt Service Routines                                           */
/************************************************************************/

ISR(TIMER0_OVF_vect){
     f78:	1f 92       	push	r1
     f7a:	0f 92       	push	r0
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	0f 92       	push	r0
     f80:	11 24       	eor	r1, r1
     f82:	8f 93       	push	r24
     f84:	9f 93       	push	r25
	adc_timer_ovf_cnt++;
     f86:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <adc_timer_ovf_cnt>
     f8a:	8f 5f       	subi	r24, 0xFF	; 255
     f8c:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <adc_timer_ovf_cnt>
	wimod_timer_ovf_cnt++;
     f90:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <wimod_timer_ovf_cnt>
     f94:	90 91 ba 06 	lds	r25, 0x06BA	; 0x8006ba <wimod_timer_ovf_cnt+0x1>
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	90 93 ba 06 	sts	0x06BA, r25	; 0x8006ba <wimod_timer_ovf_cnt+0x1>
     f9e:	80 93 b9 06 	sts	0x06B9, r24	; 0x8006b9 <wimod_timer_ovf_cnt>
}
     fa2:	9f 91       	pop	r25
     fa4:	8f 91       	pop	r24
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63
     faa:	0f 90       	pop	r0
     fac:	1f 90       	pop	r1
     fae:	18 95       	reti

00000fb0 <__vector_30>:

ISR(USART1_RX_vect)
{
     fb0:	1f 92       	push	r1
     fb2:	0f 92       	push	r0
     fb4:	0f b6       	in	r0, 0x3f	; 63
     fb6:	0f 92       	push	r0
     fb8:	11 24       	eor	r1, r1
     fba:	2f 93       	push	r18
     fbc:	3f 93       	push	r19
     fbe:	4f 93       	push	r20
     fc0:	5f 93       	push	r21
     fc2:	6f 93       	push	r22
     fc4:	7f 93       	push	r23
     fc6:	8f 93       	push	r24
     fc8:	9f 93       	push	r25
     fca:	af 93       	push	r26
     fcc:	bf 93       	push	r27
     fce:	ef 93       	push	r30
     fd0:	ff 93       	push	r31
	/* I assume no buffering is need if Wimod interface lays in between						   */
	/* This may not be needed when using the wimod process function in main loop			   */
	/* Optionally call the process function here.											   */
	/*******************************************************************************************/
	unsigned char irxdata;
	irxdata = UDR1;
     fd2:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__DATA_REGION_ORIGIN__+0x3c>
	//uart0_tx_byte(&irxdata);
	BufferIn(irxdata);
     fd6:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <BufferIn>
	
	//WiMOD_HCI_ATmega64_Process(serialRXBuffer, sizeof(serialRXBuffer));
	//WiMOD_HCI_ATmega64_Process();
	//SLIP_ProcessRxByte(&UDR1);

}
     fda:	ff 91       	pop	r31
     fdc:	ef 91       	pop	r30
     fde:	bf 91       	pop	r27
     fe0:	af 91       	pop	r26
     fe2:	9f 91       	pop	r25
     fe4:	8f 91       	pop	r24
     fe6:	7f 91       	pop	r23
     fe8:	6f 91       	pop	r22
     fea:	5f 91       	pop	r21
     fec:	4f 91       	pop	r20
     fee:	3f 91       	pop	r19
     ff0:	2f 91       	pop	r18
     ff2:	0f 90       	pop	r0
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	0f 90       	pop	r0
     ff8:	1f 90       	pop	r1
     ffa:	18 95       	reti

00000ffc <eMBFuncReadCoils>:

#if MB_FUNC_READ_COILS_ENABLED > 0

eMBException
eMBFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
{
     ffc:	1f 93       	push	r17
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    1002:	db 01       	movw	r26, r22
    1004:	2d 91       	ld	r18, X+
    1006:	3c 91       	ld	r19, X
    1008:	25 30       	cpi	r18, 0x05	; 5
    100a:	31 05       	cpc	r19, r1
    100c:	09 f0       	breq	.+2      	; 0x1010 <eMBFuncReadCoils+0x14>
    100e:	57 c0       	rjmp	.+174    	; 0x10be <eMBFuncReadCoils+0xc2>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usCoilCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] << 8 );
    1010:	fc 01       	movw	r30, r24
    1012:	43 81       	ldd	r20, Z+3	; 0x03
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	54 2f       	mov	r21, r20
    1018:	44 27       	eor	r20, r20
        usCoilCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF + 1] );
    101a:	24 81       	ldd	r18, Z+4	; 0x04
    101c:	42 2b       	or	r20, r18

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usCoilCount >= 1 ) &&
    101e:	9a 01       	movw	r18, r20
    1020:	21 50       	subi	r18, 0x01	; 1
    1022:	31 09       	sbc	r19, r1
    1024:	2f 3c       	cpi	r18, 0xCF	; 207
    1026:	37 40       	sbci	r19, 0x07	; 7
    1028:	08 f0       	brcs	.+2      	; 0x102c <eMBFuncReadCoils+0x30>
    102a:	4b c0       	rjmp	.+150    	; 0x10c2 <eMBFuncReadCoils+0xc6>
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    102c:	dc 01       	movw	r26, r24
    102e:	11 96       	adiw	r26, 0x01	; 1
    1030:	3c 91       	ld	r19, X
    1032:	11 97       	sbiw	r26, 0x01	; 1
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1034:	12 96       	adiw	r26, 0x02	; 2
    1036:	2c 91       	ld	r18, X
    1038:	12 97       	sbiw	r26, 0x02	; 2
        if( ( usCoilCount >= 1 ) &&
            ( usCoilCount < MB_PDU_FUNC_READ_COILCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
    103a:	fb 01       	movw	r30, r22
    103c:	11 82       	std	Z+1, r1	; 0x01
    103e:	10 82       	st	Z, r1

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_COILS;
    1040:	e1 e0       	ldi	r30, 0x01	; 1
    1042:	ec 93       	st	X, r30
            *usLen += 1;
    1044:	db 01       	movw	r26, r22
    1046:	ed 91       	ld	r30, X+
    1048:	fc 91       	ld	r31, X
    104a:	11 97       	sbiw	r26, 0x01	; 1
    104c:	31 96       	adiw	r30, 0x01	; 1
    104e:	ed 93       	st	X+, r30
    1050:	fc 93       	st	X, r31

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usCoilCount & 0x0007 ) != 0 )
    1052:	fa 01       	movw	r30, r20
    1054:	e7 70       	andi	r30, 0x07	; 7
    1056:	ff 27       	eor	r31, r31
    1058:	ef 2b       	or	r30, r31
    105a:	51 f0       	breq	.+20     	; 0x1070 <eMBFuncReadCoils+0x74>
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 + 1 );
    105c:	fa 01       	movw	r30, r20
    105e:	f6 95       	lsr	r31
    1060:	e7 95       	ror	r30
    1062:	f6 95       	lsr	r31
    1064:	e7 95       	ror	r30
    1066:	f6 95       	lsr	r31
    1068:	e7 95       	ror	r30
    106a:	11 e0       	ldi	r17, 0x01	; 1
    106c:	1e 0f       	add	r17, r30
    106e:	08 c0       	rjmp	.+16     	; 0x1080 <eMBFuncReadCoils+0x84>
            }
            else
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 );
    1070:	fa 01       	movw	r30, r20
    1072:	f6 95       	lsr	r31
    1074:	e7 95       	ror	r30
    1076:	f6 95       	lsr	r31
    1078:	e7 95       	ror	r30
    107a:	f6 95       	lsr	r31
    107c:	e7 95       	ror	r30
    107e:	1e 2f       	mov	r17, r30
    1080:	eb 01       	movw	r28, r22
            }
            *pucFrameCur++ = ucNBytes;
    1082:	fc 01       	movw	r30, r24
    1084:	11 83       	std	Z+1, r17	; 0x01
            *usLen += 1;
    1086:	68 81       	ld	r22, Y
    1088:	79 81       	ldd	r23, Y+1	; 0x01
    108a:	6f 5f       	subi	r22, 0xFF	; 255
    108c:	7f 4f       	sbci	r23, 0xFF	; 255
    108e:	79 83       	std	Y+1, r23	; 0x01
    1090:	68 83       	st	Y, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    1092:	62 2f       	mov	r22, r18
    1094:	70 e0       	ldi	r23, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1096:	73 2b       	or	r23, r19
                ucNBytes = ( UCHAR )( usCoilCount / 8 );
            }
            *pucFrameCur++ = ucNBytes;
            *usLen += 1;

            eRegStatus =
    1098:	6f 5f       	subi	r22, 0xFF	; 255
    109a:	7f 4f       	sbci	r23, 0xFF	; 255
    109c:	20 e0       	ldi	r18, 0x00	; 0
    109e:	02 96       	adiw	r24, 0x02	; 2
    10a0:	0e 94 ba 07 	call	0xf74	; 0xf74 <eMBRegCoilsCB>
                eMBRegCoilsCB( pucFrameCur, usRegAddress, usCoilCount,
                               MB_REG_READ );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    10a4:	88 23       	and	r24, r24
    10a6:	19 f0       	breq	.+6      	; 0x10ae <eMBFuncReadCoils+0xb2>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    10a8:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    10ac:	0b c0       	rjmp	.+22     	; 0x10c4 <eMBFuncReadCoils+0xc8>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
    10ae:	88 81       	ld	r24, Y
    10b0:	99 81       	ldd	r25, Y+1	; 0x01
    10b2:	81 0f       	add	r24, r17
    10b4:	91 1d       	adc	r25, r1
    10b6:	99 83       	std	Y+1, r25	; 0x01
    10b8:	88 83       	st	Y, r24
    USHORT          usRegAddress;
    USHORT          usCoilCount;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    10ba:	80 e0       	ldi	r24, 0x00	; 0
    10bc:	03 c0       	rjmp	.+6      	; 0x10c4 <eMBFuncReadCoils+0xc8>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    10be:	83 e0       	ldi	r24, 0x03	; 3
    10c0:	01 c0       	rjmp	.+2      	; 0x10c4 <eMBFuncReadCoils+0xc8>
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    10c2:	83 e0       	ldi	r24, 0x03	; 3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	1f 91       	pop	r17
    10ca:	08 95       	ret

000010cc <eMBFuncWriteCoil>:

#if MB_FUNC_WRITE_COIL_ENABLED > 0
eMBException
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	00 d0       	rcall	.+0      	; 0x10d2 <eMBFuncWriteCoil+0x6>
    10d2:	cd b7       	in	r28, 0x3d	; 61
    10d4:	de b7       	in	r29, 0x3e	; 62
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    10d6:	fb 01       	movw	r30, r22
    10d8:	20 81       	ld	r18, Z
    10da:	31 81       	ldd	r19, Z+1	; 0x01
    10dc:	25 30       	cpi	r18, 0x05	; 5
    10de:	31 05       	cpc	r19, r1
    10e0:	11 f5       	brne	.+68     	; 0x1126 <__stack+0x27>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
    10e2:	fc 01       	movw	r30, r24
    10e4:	24 81       	ldd	r18, Z+4	; 0x04
    10e6:	21 11       	cpse	r18, r1
    10e8:	20 c0       	rjmp	.+64     	; 0x112a <__stack+0x2b>
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
    10ea:	23 81       	ldd	r18, Z+3	; 0x03
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
    10ec:	3f ef       	ldi	r19, 0xFF	; 255
    10ee:	32 0f       	add	r19, r18
    10f0:	3e 3f       	cpi	r19, 0xFE	; 254
    10f2:	e8 f0       	brcs	.+58     	; 0x112e <__stack+0x2f>
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
    10f4:	31 81       	ldd	r19, Z+1	; 0x01
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
    10f6:	62 81       	ldd	r22, Z+2	; 0x02

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
    10f8:	1a 82       	std	Y+2, r1	; 0x02
            if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
    10fa:	2f 3f       	cpi	r18, 0xFF	; 255
    10fc:	19 f4       	brne	.+6      	; 0x1104 <__stack+0x5>
            {
                ucBuf[0] = 1;
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	89 83       	std	Y+1, r24	; 0x01
    1102:	01 c0       	rjmp	.+2      	; 0x1106 <__stack+0x7>
            }
            else
            {
                ucBuf[0] = 0;
    1104:	19 82       	std	Y+1, r1	; 0x01
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
    1106:	70 e0       	ldi	r23, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
    1108:	73 2b       	or	r23, r19
            }
            else
            {
                ucBuf[0] = 0;
            }
            eRegStatus =
    110a:	6f 5f       	subi	r22, 0xFF	; 255
    110c:	7f 4f       	sbci	r23, 0xFF	; 255
    110e:	21 e0       	ldi	r18, 0x01	; 1
    1110:	41 e0       	ldi	r20, 0x01	; 1
    1112:	50 e0       	ldi	r21, 0x00	; 0
    1114:	ce 01       	movw	r24, r28
    1116:	01 96       	adiw	r24, 0x01	; 1
    1118:	0e 94 ba 07 	call	0xf74	; 0xf74 <eMBRegCoilsCB>
                eMBRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    111c:	88 23       	and	r24, r24
    111e:	49 f0       	breq	.+18     	; 0x1132 <__stack+0x33>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    1120:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    1124:	07 c0       	rjmp	.+14     	; 0x1134 <__stack+0x35>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    1126:	83 e0       	ldi	r24, 0x03	; 3
    1128:	05 c0       	rjmp	.+10     	; 0x1134 <__stack+0x35>
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    112a:	83 e0       	ldi	r24, 0x03	; 3
    112c:	03 c0       	rjmp	.+6      	; 0x1134 <__stack+0x35>
    112e:	83 e0       	ldi	r24, 0x03	; 3
    1130:	01 c0       	rjmp	.+2      	; 0x1134 <__stack+0x35>
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
    1132:	80 e0       	ldi	r24, 0x00	; 0
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    1134:	0f 90       	pop	r0
    1136:	0f 90       	pop	r0
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	08 95       	ret

0000113e <eMBFuncWriteMultipleCoils>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED > 0
eMBException
eMBFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
{
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    1142:	fb 01       	movw	r30, r22
    1144:	20 81       	ld	r18, Z
    1146:	31 81       	ldd	r19, Z+1	; 0x01
    1148:	26 30       	cpi	r18, 0x06	; 6
    114a:	31 05       	cpc	r19, r1
    114c:	e8 f1       	brcs	.+122    	; 0x11c8 <eMBFuncWriteMultipleCoils+0x8a>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
        usRegAddress++;

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
    114e:	fc 01       	movw	r30, r24
    1150:	43 81       	ldd	r20, Z+3	; 0x03
    1152:	50 e0       	ldi	r21, 0x00	; 0
    1154:	54 2f       	mov	r21, r20
    1156:	44 27       	eor	r20, r20
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
    1158:	24 81       	ldd	r18, Z+4	; 0x04
    115a:	42 2b       	or	r20, r18

        ucByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];

        /* Compute the number of expected bytes in the request. */
        if( ( usCoilCnt & 0x0007 ) != 0 )
    115c:	9a 01       	movw	r18, r20
    115e:	27 70       	andi	r18, 0x07	; 7
    1160:	33 27       	eor	r19, r19
    1162:	23 2b       	or	r18, r19
    1164:	49 f0       	breq	.+18     	; 0x1178 <eMBFuncWriteMultipleCoils+0x3a>
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
    1166:	9a 01       	movw	r18, r20
    1168:	36 95       	lsr	r19
    116a:	27 95       	ror	r18
    116c:	36 95       	lsr	r19
    116e:	27 95       	ror	r18
    1170:	36 95       	lsr	r19
    1172:	27 95       	ror	r18
    1174:	2f 5f       	subi	r18, 0xFF	; 255
    1176:	07 c0       	rjmp	.+14     	; 0x1186 <eMBFuncWriteMultipleCoils+0x48>
        }
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
    1178:	9a 01       	movw	r18, r20
    117a:	36 95       	lsr	r19
    117c:	27 95       	ror	r18
    117e:	36 95       	lsr	r19
    1180:	27 95       	ror	r18
    1182:	36 95       	lsr	r19
    1184:	27 95       	ror	r18
        }

        if( ( usCoilCnt >= 1 ) &&
    1186:	fa 01       	movw	r30, r20
    1188:	31 97       	sbiw	r30, 0x01	; 1
    118a:	e0 3b       	cpi	r30, 0xB0	; 176
    118c:	f7 40       	sbci	r31, 0x07	; 7
    118e:	f0 f4       	brcc	.+60     	; 0x11cc <eMBFuncWriteMultipleCoils+0x8e>
            ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
    1190:	fc 01       	movw	r30, r24
    1192:	35 81       	ldd	r19, Z+5	; 0x05
    1194:	23 13       	cpse	r18, r19
    1196:	1c c0       	rjmp	.+56     	; 0x11d0 <eMBFuncWriteMultipleCoils+0x92>
    1198:	eb 01       	movw	r28, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
    119a:	61 81       	ldd	r22, Z+1	; 0x01
    119c:	70 e0       	ldi	r23, 0x00	; 0
    119e:	76 2f       	mov	r23, r22
    11a0:	66 27       	eor	r22, r22
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
    11a2:	22 81       	ldd	r18, Z+2	; 0x02
    11a4:	62 2b       	or	r22, r18

        if( ( usCoilCnt >= 1 ) &&
            ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
            ( ucByteCountVerify == ucByteCount ) )
        {
            eRegStatus =
    11a6:	6f 5f       	subi	r22, 0xFF	; 255
    11a8:	7f 4f       	sbci	r23, 0xFF	; 255
    11aa:	21 e0       	ldi	r18, 0x01	; 1
    11ac:	06 96       	adiw	r24, 0x06	; 6
    11ae:	0e 94 ba 07 	call	0xf74	; 0xf74 <eMBRegCoilsCB>
                eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                               usRegAddress, usCoilCnt, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    11b2:	88 23       	and	r24, r24
    11b4:	19 f0       	breq	.+6      	; 0x11bc <eMBFuncWriteMultipleCoils+0x7e>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    11b6:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    11ba:	0b c0       	rjmp	.+22     	; 0x11d2 <eMBFuncWriteMultipleCoils+0x94>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
    11bc:	85 e0       	ldi	r24, 0x05	; 5
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	99 83       	std	Y+1, r25	; 0x01
    11c2:	88 83       	st	Y, r24
    USHORT          usRegAddress;
    USHORT          usCoilCnt;
    UCHAR           ucByteCount;
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	05 c0       	rjmp	.+10     	; 0x11d2 <eMBFuncWriteMultipleCoils+0x94>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    11c8:	83 e0       	ldi	r24, 0x03	; 3
    11ca:	03 c0       	rjmp	.+6      	; 0x11d2 <eMBFuncWriteMultipleCoils+0x94>
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    11cc:	83 e0       	ldi	r24, 0x03	; 3
    11ce:	01 c0       	rjmp	.+2      	; 0x11d2 <eMBFuncWriteMultipleCoils+0x94>
    11d0:	83 e0       	ldi	r24, 0x03	; 3
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	08 95       	ret

000011d8 <eMBFuncReadDiscreteInputs>:

#if MB_FUNC_READ_COILS_ENABLED > 0

eMBException
eMBFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
{
    11d8:	1f 93       	push	r17
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    11de:	db 01       	movw	r26, r22
    11e0:	2d 91       	ld	r18, X+
    11e2:	3c 91       	ld	r19, X
    11e4:	25 30       	cpi	r18, 0x05	; 5
    11e6:	31 05       	cpc	r19, r1
    11e8:	09 f0       	breq	.+2      	; 0x11ec <eMBFuncReadDiscreteInputs+0x14>
    11ea:	56 c0       	rjmp	.+172    	; 0x1298 <eMBFuncReadDiscreteInputs+0xc0>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usDiscreteCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF] << 8 );
    11ec:	fc 01       	movw	r30, r24
    11ee:	43 81       	ldd	r20, Z+3	; 0x03
    11f0:	50 e0       	ldi	r21, 0x00	; 0
    11f2:	54 2f       	mov	r21, r20
    11f4:	44 27       	eor	r20, r20
        usDiscreteCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF + 1] );
    11f6:	24 81       	ldd	r18, Z+4	; 0x04
    11f8:	42 2b       	or	r20, r18

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usDiscreteCnt >= 1 ) &&
    11fa:	9a 01       	movw	r18, r20
    11fc:	21 50       	subi	r18, 0x01	; 1
    11fe:	31 09       	sbc	r19, r1
    1200:	2f 3c       	cpi	r18, 0xCF	; 207
    1202:	37 40       	sbci	r19, 0x07	; 7
    1204:	08 f0       	brcs	.+2      	; 0x1208 <eMBFuncReadDiscreteInputs+0x30>
    1206:	4a c0       	rjmp	.+148    	; 0x129c <eMBFuncReadDiscreteInputs+0xc4>
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    1208:	dc 01       	movw	r26, r24
    120a:	11 96       	adiw	r26, 0x01	; 1
    120c:	3c 91       	ld	r19, X
    120e:	11 97       	sbiw	r26, 0x01	; 1
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1210:	12 96       	adiw	r26, 0x02	; 2
    1212:	2c 91       	ld	r18, X
    1214:	12 97       	sbiw	r26, 0x02	; 2
        if( ( usDiscreteCnt >= 1 ) &&
            ( usDiscreteCnt < MB_PDU_FUNC_READ_DISCCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
    1216:	fb 01       	movw	r30, r22
    1218:	11 82       	std	Z+1, r1	; 0x01
    121a:	10 82       	st	Z, r1

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_DISCRETE_INPUTS;
    121c:	e2 e0       	ldi	r30, 0x02	; 2
    121e:	ec 93       	st	X, r30
            *usLen += 1;
    1220:	db 01       	movw	r26, r22
    1222:	ed 91       	ld	r30, X+
    1224:	fc 91       	ld	r31, X
    1226:	11 97       	sbiw	r26, 0x01	; 1
    1228:	31 96       	adiw	r30, 0x01	; 1
    122a:	ed 93       	st	X+, r30
    122c:	fc 93       	st	X, r31

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usDiscreteCnt & 0x0007 ) != 0 )
    122e:	fa 01       	movw	r30, r20
    1230:	e7 70       	andi	r30, 0x07	; 7
    1232:	ff 27       	eor	r31, r31
    1234:	ef 2b       	or	r30, r31
    1236:	51 f0       	breq	.+20     	; 0x124c <eMBFuncReadDiscreteInputs+0x74>
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 + 1 );
    1238:	fa 01       	movw	r30, r20
    123a:	f6 95       	lsr	r31
    123c:	e7 95       	ror	r30
    123e:	f6 95       	lsr	r31
    1240:	e7 95       	ror	r30
    1242:	f6 95       	lsr	r31
    1244:	e7 95       	ror	r30
    1246:	11 e0       	ldi	r17, 0x01	; 1
    1248:	1e 0f       	add	r17, r30
    124a:	08 c0       	rjmp	.+16     	; 0x125c <eMBFuncReadDiscreteInputs+0x84>
            }
            else
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
    124c:	fa 01       	movw	r30, r20
    124e:	f6 95       	lsr	r31
    1250:	e7 95       	ror	r30
    1252:	f6 95       	lsr	r31
    1254:	e7 95       	ror	r30
    1256:	f6 95       	lsr	r31
    1258:	e7 95       	ror	r30
    125a:	1e 2f       	mov	r17, r30
    125c:	eb 01       	movw	r28, r22
            }
            *pucFrameCur++ = ucNBytes;
    125e:	fc 01       	movw	r30, r24
    1260:	11 83       	std	Z+1, r17	; 0x01
            *usLen += 1;
    1262:	68 81       	ld	r22, Y
    1264:	79 81       	ldd	r23, Y+1	; 0x01
    1266:	6f 5f       	subi	r22, 0xFF	; 255
    1268:	7f 4f       	sbci	r23, 0xFF	; 255
    126a:	79 83       	std	Y+1, r23	; 0x01
    126c:	68 83       	st	Y, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    126e:	62 2f       	mov	r22, r18
    1270:	70 e0       	ldi	r23, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1272:	73 2b       	or	r23, r19
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
            }
            *pucFrameCur++ = ucNBytes;
            *usLen += 1;

            eRegStatus =
    1274:	6f 5f       	subi	r22, 0xFF	; 255
    1276:	7f 4f       	sbci	r23, 0xFF	; 255
    1278:	02 96       	adiw	r24, 0x02	; 2
    127a:	0e 94 b8 07 	call	0xf70	; 0xf70 <eMBRegDiscreteCB>
                eMBRegDiscreteCB( pucFrameCur, usRegAddress, usDiscreteCnt );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    127e:	88 23       	and	r24, r24
    1280:	19 f0       	breq	.+6      	; 0x1288 <eMBFuncReadDiscreteInputs+0xb0>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    1282:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    1286:	0b c0       	rjmp	.+22     	; 0x129e <eMBFuncReadDiscreteInputs+0xc6>
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
    1288:	88 81       	ld	r24, Y
    128a:	99 81       	ldd	r25, Y+1	; 0x01
    128c:	81 0f       	add	r24, r17
    128e:	91 1d       	adc	r25, r1
    1290:	99 83       	std	Y+1, r25	; 0x01
    1292:	88 83       	st	Y, r24
    USHORT          usRegAddress;
    USHORT          usDiscreteCnt;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    1294:	80 e0       	ldi	r24, 0x00	; 0
    1296:	03 c0       	rjmp	.+6      	; 0x129e <eMBFuncReadDiscreteInputs+0xc6>
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    1298:	83 e0       	ldi	r24, 0x03	; 3
    129a:	01 c0       	rjmp	.+2      	; 0x129e <eMBFuncReadDiscreteInputs+0xc6>
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    129c:	83 e0       	ldi	r24, 0x03	; 3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	1f 91       	pop	r17
    12a4:	08 95       	ret

000012a6 <eMBFuncWriteHoldingRegister>:
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    12a6:	fb 01       	movw	r30, r22
    12a8:	20 81       	ld	r18, Z
    12aa:	31 81       	ldd	r19, Z+1	; 0x01
    12ac:	25 30       	cpi	r18, 0x05	; 5
    12ae:	31 05       	cpc	r19, r1
    12b0:	a1 f4       	brne	.+40     	; 0x12da <eMBFuncWriteHoldingRegister+0x34>
    12b2:	fc 01       	movw	r30, r24
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
    12b4:	61 81       	ldd	r22, Z+1	; 0x01
    12b6:	70 e0       	ldi	r23, 0x00	; 0
    12b8:	76 2f       	mov	r23, r22
    12ba:	66 27       	eor	r22, r22
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
    12bc:	22 81       	ldd	r18, Z+2	; 0x02
    12be:	62 2b       	or	r22, r18
        usRegAddress++;

        /* Make callback to update the value. */
        eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF],
    12c0:	6f 5f       	subi	r22, 0xFF	; 255
    12c2:	7f 4f       	sbci	r23, 0xFF	; 255
    12c4:	21 e0       	ldi	r18, 0x01	; 1
    12c6:	41 e0       	ldi	r20, 0x01	; 1
    12c8:	50 e0       	ldi	r21, 0x00	; 0
    12ca:	03 96       	adiw	r24, 0x03	; 3
    12cc:	0e 94 4d 07 	call	0xe9a	; 0xe9a <eMBRegHoldingCB>
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
    12d0:	88 23       	and	r24, r24
    12d2:	29 f0       	breq	.+10     	; 0x12de <eMBFuncWriteHoldingRegister+0x38>
        {
            eStatus = prveMBError2Exception( eRegStatus );
    12d4:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    12d8:	08 95       	ret
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    12da:	83 e0       	ldi	r24, 0x03	; 3
    12dc:	08 95       	ret

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    12de:	80 e0       	ldi	r24, 0x00	; 0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    12e0:	08 95       	ret

000012e2 <eMBFuncWriteMultipleHoldingRegister>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED > 0
eMBException
eMBFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    12e2:	cf 93       	push	r28
    12e4:	df 93       	push	r29
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    12e6:	fb 01       	movw	r30, r22
    12e8:	20 81       	ld	r18, Z
    12ea:	31 81       	ldd	r19, Z+1	; 0x01
    12ec:	26 30       	cpi	r18, 0x06	; 6
    12ee:	31 05       	cpc	r19, r1
    12f0:	50 f1       	brcs	.+84     	; 0x1346 <eMBFuncWriteMultipleHoldingRegister+0x64>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
        usRegAddress++;

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF] << 8 );
    12f2:	fc 01       	movw	r30, r24
    12f4:	43 81       	ldd	r20, Z+3	; 0x03
    12f6:	50 e0       	ldi	r21, 0x00	; 0
    12f8:	54 2f       	mov	r21, r20
    12fa:	44 27       	eor	r20, r20
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );
    12fc:	24 81       	ldd	r18, Z+4	; 0x04
    12fe:	42 2b       	or	r20, r18

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];

        if( ( usRegCount >= 1 ) &&
    1300:	9a 01       	movw	r18, r20
    1302:	21 50       	subi	r18, 0x01	; 1
    1304:	31 09       	sbc	r19, r1
    1306:	28 37       	cpi	r18, 0x78	; 120
    1308:	31 05       	cpc	r19, r1
    130a:	f8 f4       	brcc	.+62     	; 0x134a <eMBFuncWriteMultipleHoldingRegister+0x68>
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
    130c:	35 81       	ldd	r19, Z+5	; 0x05
    130e:	24 2f       	mov	r18, r20
    1310:	22 0f       	add	r18, r18
    1312:	32 13       	cpse	r19, r18
    1314:	1c c0       	rjmp	.+56     	; 0x134e <eMBFuncWriteMultipleHoldingRegister+0x6c>
    1316:	eb 01       	movw	r28, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
    1318:	61 81       	ldd	r22, Z+1	; 0x01
    131a:	70 e0       	ldi	r23, 0x00	; 0
    131c:	76 2f       	mov	r23, r22
    131e:	66 27       	eor	r22, r22
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
    1320:	22 81       	ldd	r18, Z+2	; 0x02
    1322:	62 2b       	or	r22, r18
        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
        {
            /* Make callback to update the register values. */
            eRegStatus =
    1324:	6f 5f       	subi	r22, 0xFF	; 255
    1326:	7f 4f       	sbci	r23, 0xFF	; 255
    1328:	21 e0       	ldi	r18, 0x01	; 1
    132a:	06 96       	adiw	r24, 0x06	; 6
    132c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <eMBRegHoldingCB>
                eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                                 usRegAddress, usRegCount, MB_REG_WRITE );

            /* If an error occurred convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    1330:	88 23       	and	r24, r24
    1332:	19 f0       	breq	.+6      	; 0x133a <eMBFuncWriteMultipleHoldingRegister+0x58>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    1334:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    1338:	0b c0       	rjmp	.+22     	; 0x1350 <eMBFuncWriteMultipleHoldingRegister+0x6e>
            {
                /* The response contains the function code, the starting
                 * address and the quantity of registers. We reuse the
                 * old values in the buffer because they are still valid.
                 */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
    133a:	85 e0       	ldi	r24, 0x05	; 5
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	99 83       	std	Y+1, r25	; 0x01
    1340:	88 83       	st	Y, r24
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	05 c0       	rjmp	.+10     	; 0x1350 <eMBFuncWriteMultipleHoldingRegister+0x6e>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    1346:	83 e0       	ldi	r24, 0x03	; 3
    1348:	03 c0       	rjmp	.+6      	; 0x1350 <eMBFuncWriteMultipleHoldingRegister+0x6e>
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    134a:	83 e0       	ldi	r24, 0x03	; 3
    134c:	01 c0       	rjmp	.+2      	; 0x1350 <eMBFuncWriteMultipleHoldingRegister+0x6e>
    134e:	83 e0       	ldi	r24, 0x03	; 3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    1350:	df 91       	pop	r29
    1352:	cf 91       	pop	r28
    1354:	08 95       	ret

00001356 <eMBFuncReadHoldingRegister>:

#if MB_FUNC_READ_HOLDING_ENABLED > 0

eMBException
eMBFuncReadHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    1356:	0f 93       	push	r16
    1358:	1f 93       	push	r17
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    135e:	fb 01       	movw	r30, r22
    1360:	20 81       	ld	r18, Z
    1362:	31 81       	ldd	r19, Z+1	; 0x01
    1364:	25 30       	cpi	r18, 0x05	; 5
    1366:	31 05       	cpc	r19, r1
    1368:	b1 f5       	brne	.+108    	; 0x13d6 <eMBFuncReadHoldingRegister+0x80>
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
    136a:	fc 01       	movw	r30, r24
    136c:	24 81       	ldd	r18, Z+4	; 0x04
    136e:	02 2f       	mov	r16, r18
    1370:	10 e0       	ldi	r17, 0x00	; 0

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 ) && ( usRegCount <= MB_PDU_FUNC_READ_REGCNT_MAX ) )
    1372:	a8 01       	movw	r20, r16
    1374:	41 50       	subi	r20, 0x01	; 1
    1376:	51 09       	sbc	r21, r1
    1378:	4d 37       	cpi	r20, 0x7D	; 125
    137a:	51 05       	cpc	r21, r1
    137c:	70 f5       	brcc	.+92     	; 0x13da <eMBFuncReadHoldingRegister+0x84>
    137e:	eb 01       	movw	r28, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    1380:	31 81       	ldd	r19, Z+1	; 0x01
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1382:	62 81       	ldd	r22, Z+2	; 0x02
         */
        if( ( usRegCount >= 1 ) && ( usRegCount <= MB_PDU_FUNC_READ_REGCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
    1384:	19 82       	std	Y+1, r1	; 0x01
    1386:	18 82       	st	Y, r1

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_HOLDING_REGISTER;
    1388:	83 e0       	ldi	r24, 0x03	; 3
    138a:	80 83       	st	Z, r24
            *usLen += 1;
    138c:	88 81       	ld	r24, Y
    138e:	99 81       	ldd	r25, Y+1	; 0x01
    1390:	01 96       	adiw	r24, 0x01	; 1
    1392:	99 83       	std	Y+1, r25	; 0x01
    1394:	88 83       	st	Y, r24

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
    1396:	22 0f       	add	r18, r18
    1398:	21 83       	std	Z+1, r18	; 0x01
            *usLen += 1;
    139a:	88 81       	ld	r24, Y
    139c:	99 81       	ldd	r25, Y+1	; 0x01
    139e:	01 96       	adiw	r24, 0x01	; 1
    13a0:	99 83       	std	Y+1, r25	; 0x01
    13a2:	88 83       	st	Y, r24
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    13a4:	70 e0       	ldi	r23, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    13a6:	73 2b       	or	r23, r19
            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
            *usLen += 1;

            /* Make callback to fill the buffer. */
            eRegStatus = eMBRegHoldingCB( pucFrameCur, usRegAddress, usRegCount, MB_REG_READ );
    13a8:	6f 5f       	subi	r22, 0xFF	; 255
    13aa:	7f 4f       	sbci	r23, 0xFF	; 255
    13ac:	20 e0       	ldi	r18, 0x00	; 0
    13ae:	a8 01       	movw	r20, r16
    13b0:	cf 01       	movw	r24, r30
    13b2:	02 96       	adiw	r24, 0x02	; 2
    13b4:	0e 94 4d 07 	call	0xe9a	; 0xe9a <eMBRegHoldingCB>
            /* If an error occurred convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    13b8:	88 23       	and	r24, r24
    13ba:	19 f0       	breq	.+6      	; 0x13c2 <eMBFuncReadHoldingRegister+0x6c>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    13bc:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    13c0:	0d c0       	rjmp	.+26     	; 0x13dc <eMBFuncReadHoldingRegister+0x86>
            }
            else
            {
                *usLen += usRegCount * 2;
    13c2:	00 0f       	add	r16, r16
    13c4:	11 1f       	adc	r17, r17
    13c6:	88 81       	ld	r24, Y
    13c8:	99 81       	ldd	r25, Y+1	; 0x01
    13ca:	08 0f       	add	r16, r24
    13cc:	19 1f       	adc	r17, r25
    13ce:	19 83       	std	Y+1, r17	; 0x01
    13d0:	08 83       	st	Y, r16
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	03 c0       	rjmp	.+6      	; 0x13dc <eMBFuncReadHoldingRegister+0x86>
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    13d6:	83 e0       	ldi	r24, 0x03	; 3
    13d8:	01 c0       	rjmp	.+2      	; 0x13dc <eMBFuncReadHoldingRegister+0x86>
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    13da:	83 e0       	ldi	r24, 0x03	; 3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	1f 91       	pop	r17
    13e2:	0f 91       	pop	r16
    13e4:	08 95       	ret

000013e6 <eMBFuncReadWriteMultipleHoldingRegister>:

#if MB_FUNC_READWRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncReadWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    13f6:	fb 01       	movw	r30, r22
    13f8:	20 81       	ld	r18, Z
    13fa:	31 81       	ldd	r19, Z+1	; 0x01
    13fc:	2a 30       	cpi	r18, 0x0A	; 10
    13fe:	31 05       	cpc	r19, r1
    1400:	08 f4       	brcc	.+2      	; 0x1404 <eMBFuncReadWriteMultipleHoldingRegister+0x1e>
    1402:	66 c0       	rjmp	.+204    	; 0x14d0 <eMBFuncReadWriteMultipleHoldingRegister+0xea>
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
    1404:	fc 01       	movw	r30, r24
    1406:	c3 81       	ldd	r28, Z+3	; 0x03
    1408:	d0 e0       	ldi	r29, 0x00	; 0
    140a:	dc 2f       	mov	r29, r28
    140c:	cc 27       	eor	r28, r28
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );
    140e:	24 81       	ldd	r18, Z+4	; 0x04
    1410:	c2 2b       	or	r28, r18
        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
    1412:	9e 01       	movw	r18, r28
    1414:	21 50       	subi	r18, 0x01	; 1
    1416:	31 09       	sbc	r19, r1
    1418:	2d 37       	cpi	r18, 0x7D	; 125
    141a:	31 05       	cpc	r19, r1
    141c:	08 f0       	brcs	.+2      	; 0x1420 <eMBFuncReadWriteMultipleHoldingRegister+0x3a>
    141e:	5a c0       	rjmp	.+180    	; 0x14d4 <eMBFuncReadWriteMultipleHoldingRegister+0xee>

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
        usRegWriteAddress++;

        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
    1420:	47 81       	ldd	r20, Z+7	; 0x07
    1422:	50 e0       	ldi	r21, 0x00	; 0
    1424:	54 2f       	mov	r21, r20
    1426:	44 27       	eor	r20, r20
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );
    1428:	20 85       	ldd	r18, Z+8	; 0x08
    142a:	42 2b       	or	r20, r18

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
    142c:	9a 01       	movw	r18, r20
    142e:	21 50       	subi	r18, 0x01	; 1
    1430:	31 09       	sbc	r19, r1
    1432:	29 37       	cpi	r18, 0x79	; 121
    1434:	31 05       	cpc	r19, r1
    1436:	08 f0       	brcs	.+2      	; 0x143a <eMBFuncReadWriteMultipleHoldingRegister+0x54>
    1438:	4f c0       	rjmp	.+158    	; 0x14d8 <eMBFuncReadWriteMultipleHoldingRegister+0xf2>
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
    143a:	21 85       	ldd	r18, Z+9	; 0x09
    143c:	30 e0       	ldi	r19, 0x00	; 0
    143e:	fa 01       	movw	r30, r20
    1440:	ee 0f       	add	r30, r30
    1442:	ff 1f       	adc	r31, r31
    1444:	e2 17       	cp	r30, r18
    1446:	f3 07       	cpc	r31, r19
    1448:	09 f0       	breq	.+2      	; 0x144c <eMBFuncReadWriteMultipleHoldingRegister+0x66>
    144a:	48 c0       	rjmp	.+144    	; 0x14dc <eMBFuncReadWriteMultipleHoldingRegister+0xf6>
    144c:	8b 01       	movw	r16, r22
    144e:	7c 01       	movw	r14, r24
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
    1450:	fc 01       	movw	r30, r24
    1452:	c1 80       	ldd	r12, Z+1	; 0x01
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
    1454:	d2 80       	ldd	r13, Z+2	; 0x02
        usRegReadAddress++;

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
    1456:	65 81       	ldd	r22, Z+5	; 0x05
    1458:	70 e0       	ldi	r23, 0x00	; 0
    145a:	76 2f       	mov	r23, r22
    145c:	66 27       	eor	r22, r22
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
    145e:	86 81       	ldd	r24, Z+6	; 0x06
    1460:	68 2b       	or	r22, r24
        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
        {
            /* Make callback to update the register values. */
            eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_READWRITE_WRITE_VALUES_OFF],
    1462:	6f 5f       	subi	r22, 0xFF	; 255
    1464:	7f 4f       	sbci	r23, 0xFF	; 255
    1466:	21 e0       	ldi	r18, 0x01	; 1
    1468:	c7 01       	movw	r24, r14
    146a:	0a 96       	adiw	r24, 0x0a	; 10
    146c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <eMBRegHoldingCB>
                                          usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
    1470:	81 11       	cpse	r24, r1
    1472:	36 c0       	rjmp	.+108    	; 0x14e0 <eMBFuncReadWriteMultipleHoldingRegister+0xfa>
            {
                /* Set the current PDU data pointer to the beginning. */
                pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
                *usLen = MB_PDU_FUNC_OFF;
    1474:	f8 01       	movw	r30, r16
    1476:	11 82       	std	Z+1, r1	; 0x01
    1478:	10 82       	st	Z, r1

                /* First byte contains the function code. */
                *pucFrameCur++ = MB_FUNC_READWRITE_MULTIPLE_REGISTERS;
    147a:	87 e1       	ldi	r24, 0x17	; 23
    147c:	f7 01       	movw	r30, r14
    147e:	80 83       	st	Z, r24
                *usLen += 1;
    1480:	f8 01       	movw	r30, r16
    1482:	80 81       	ld	r24, Z
    1484:	91 81       	ldd	r25, Z+1	; 0x01
    1486:	01 96       	adiw	r24, 0x01	; 1
    1488:	91 83       	std	Z+1, r25	; 0x01
    148a:	80 83       	st	Z, r24

                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
    148c:	8c 2f       	mov	r24, r28
    148e:	88 0f       	add	r24, r24
    1490:	f7 01       	movw	r30, r14
    1492:	81 83       	std	Z+1, r24	; 0x01
                *usLen += 1;
    1494:	f8 01       	movw	r30, r16
    1496:	80 81       	ld	r24, Z
    1498:	91 81       	ldd	r25, Z+1	; 0x01
    149a:	01 96       	adiw	r24, 0x01	; 1
    149c:	91 83       	std	Z+1, r25	; 0x01
    149e:	80 83       	st	Z, r24
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
    14a0:	6d 2d       	mov	r22, r13
    14a2:	70 e0       	ldi	r23, 0x00	; 0
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
    14a4:	7c 29       	or	r23, r12
                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
                *usLen += 1;

                /* Make the read callback. */
                eRegStatus =
    14a6:	6f 5f       	subi	r22, 0xFF	; 255
    14a8:	7f 4f       	sbci	r23, 0xFF	; 255
    14aa:	20 e0       	ldi	r18, 0x00	; 0
    14ac:	ae 01       	movw	r20, r28
    14ae:	c7 01       	movw	r24, r14
    14b0:	02 96       	adiw	r24, 0x02	; 2
    14b2:	0e 94 4d 07 	call	0xe9a	; 0xe9a <eMBRegHoldingCB>
                    eMBRegHoldingCB( pucFrameCur, usRegReadAddress, usRegReadCount, MB_REG_READ );
                if( eRegStatus == MB_ENOERR )
    14b6:	81 11       	cpse	r24, r1
    14b8:	13 c0       	rjmp	.+38     	; 0x14e0 <eMBFuncReadWriteMultipleHoldingRegister+0xfa>
                {
                    *usLen += 2 * usRegReadCount;
    14ba:	cc 0f       	add	r28, r28
    14bc:	dd 1f       	adc	r29, r29
    14be:	f8 01       	movw	r30, r16
    14c0:	80 81       	ld	r24, Z
    14c2:	91 81       	ldd	r25, Z+1	; 0x01
    14c4:	8c 0f       	add	r24, r28
    14c6:	9d 1f       	adc	r25, r29
    14c8:	91 83       	std	Z+1, r25	; 0x01
    14ca:	80 83       	st	Z, r24
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	0a c0       	rjmp	.+20     	; 0x14e4 <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	08 c0       	rjmp	.+16     	; 0x14e4 <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    14d4:	83 e0       	ldi	r24, 0x03	; 3
    14d6:	06 c0       	rjmp	.+12     	; 0x14e4 <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
    14d8:	83 e0       	ldi	r24, 0x03	; 3
    14da:	04 c0       	rjmp	.+8      	; 0x14e4 <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
    14dc:	83 e0       	ldi	r24, 0x03	; 3
    14de:	02 c0       	rjmp	.+4      	; 0x14e4 <eMBFuncReadWriteMultipleHoldingRegister+0xfe>
                    *usLen += 2 * usRegReadCount;
                }
            }
            if( eRegStatus != MB_ENOERR )
            {
                eStatus = prveMBError2Exception( eRegStatus );
    14e0:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
        }
    }
    return eStatus;
}
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	1f 91       	pop	r17
    14ea:	0f 91       	pop	r16
    14ec:	ff 90       	pop	r15
    14ee:	ef 90       	pop	r14
    14f0:	df 90       	pop	r13
    14f2:	cf 90       	pop	r12
    14f4:	08 95       	ret

000014f6 <eMBFuncReadInputRegister>:
/* ----------------------- Start implementation -----------------------------*/
#if MB_FUNC_READ_INPUT_ENABLED > 0

eMBException
eMBFuncReadInputRegister( UCHAR * pucFrame, USHORT * usLen )
{
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    14fe:	fb 01       	movw	r30, r22
    1500:	20 81       	ld	r18, Z
    1502:	31 81       	ldd	r19, Z+1	; 0x01
    1504:	25 30       	cpi	r18, 0x05	; 5
    1506:	31 05       	cpc	r19, r1
    1508:	c9 f5       	brne	.+114    	; 0x157c <eMBFuncReadInputRegister+0x86>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
        usRegAddress++;

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
    150a:	fc 01       	movw	r30, r24
    150c:	03 81       	ldd	r16, Z+3	; 0x03
    150e:	10 e0       	ldi	r17, 0x00	; 0
    1510:	10 2f       	mov	r17, r16
    1512:	00 27       	eor	r16, r16
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
    1514:	24 81       	ldd	r18, Z+4	; 0x04
    1516:	02 2b       	or	r16, r18

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 )
    1518:	98 01       	movw	r18, r16
    151a:	21 50       	subi	r18, 0x01	; 1
    151c:	31 09       	sbc	r19, r1
    151e:	2c 37       	cpi	r18, 0x7C	; 124
    1520:	31 05       	cpc	r19, r1
    1522:	70 f5       	brcc	.+92     	; 0x1580 <eMBFuncReadInputRegister+0x8a>
    1524:	eb 01       	movw	r28, r22
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    1526:	21 81       	ldd	r18, Z+1	; 0x01
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    1528:	62 81       	ldd	r22, Z+2	; 0x02
        if( ( usRegCount >= 1 )
            && ( usRegCount < MB_PDU_FUNC_READ_REGCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
    152a:	19 82       	std	Y+1, r1	; 0x01
    152c:	18 82       	st	Y, r1

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_INPUT_REGISTER;
    152e:	84 e0       	ldi	r24, 0x04	; 4
    1530:	80 83       	st	Z, r24
            *usLen += 1;
    1532:	88 81       	ld	r24, Y
    1534:	99 81       	ldd	r25, Y+1	; 0x01
    1536:	01 96       	adiw	r24, 0x01	; 1
    1538:	99 83       	std	Y+1, r25	; 0x01
    153a:	88 83       	st	Y, r24

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR )( usRegCount * 2 );
    153c:	80 2f       	mov	r24, r16
    153e:	88 0f       	add	r24, r24
    1540:	81 83       	std	Z+1, r24	; 0x01
            *usLen += 1;
    1542:	88 81       	ld	r24, Y
    1544:	99 81       	ldd	r25, Y+1	; 0x01
    1546:	01 96       	adiw	r24, 0x01	; 1
    1548:	99 83       	std	Y+1, r25	; 0x01
    154a:	88 83       	st	Y, r24
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
    154c:	70 e0       	ldi	r23, 0x00	; 0
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
    154e:	72 2b       	or	r23, r18

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR )( usRegCount * 2 );
            *usLen += 1;

            eRegStatus =
    1550:	6f 5f       	subi	r22, 0xFF	; 255
    1552:	7f 4f       	sbci	r23, 0xFF	; 255
    1554:	a8 01       	movw	r20, r16
    1556:	cf 01       	movw	r24, r30
    1558:	02 96       	adiw	r24, 0x02	; 2
    155a:	0e 94 1e 07 	call	0xe3c	; 0xe3c <eMBRegInputCB>
                eMBRegInputCB( pucFrameCur, usRegAddress, usRegCount );

            /* If an error occurred convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
    155e:	88 23       	and	r24, r24
    1560:	19 f0       	breq	.+6      	; 0x1568 <eMBFuncReadInputRegister+0x72>
            {
                eStatus = prveMBError2Exception( eRegStatus );
    1562:	0e 94 0a 0b 	call	0x1614	; 0x1614 <prveMBError2Exception>
    1566:	0d c0       	rjmp	.+26     	; 0x1582 <eMBFuncReadInputRegister+0x8c>
            }
            else
            {
                *usLen += usRegCount * 2;
    1568:	00 0f       	add	r16, r16
    156a:	11 1f       	adc	r17, r17
    156c:	88 81       	ld	r24, Y
    156e:	99 81       	ldd	r25, Y+1	; 0x01
    1570:	08 0f       	add	r16, r24
    1572:	19 1f       	adc	r17, r25
    1574:	19 83       	std	Y+1, r17	; 0x01
    1576:	08 83       	st	Y, r16
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	03 c0       	rjmp	.+6      	; 0x1582 <eMBFuncReadInputRegister+0x8c>
    }
    else
    {
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    157c:	83 e0       	ldi	r24, 0x03	; 3
    157e:	01 c0       	rjmp	.+2      	; 0x1582 <eMBFuncReadInputRegister+0x8c>
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    1580:	83 e0       	ldi	r24, 0x03	; 3
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	1f 91       	pop	r17
    1588:	0f 91       	pop	r16
    158a:	08 95       	ret

0000158c <eMBSetSlaveID>:
/* ----------------------- Start implementation -----------------------------*/

eMBErrorCode
eMBSetSlaveID( UCHAR ucSlaveID, BOOL xIsRunning,
               UCHAR const *pucAdditional, USHORT usAdditionalLen )
{
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
    eMBErrorCode    eStatus = MB_ENOERR;

    /* the first byte and second byte in the buffer is reserved for
     * the parameter ucSlaveID and the running flag. The rest of
     * the buffer is available for additional data. */
    if( usAdditionalLen + 2 < MB_FUNC_OTHER_REP_SLAVEID_BUF )
    1590:	e9 01       	movw	r28, r18
    1592:	22 96       	adiw	r28, 0x02	; 2
    1594:	c0 32       	cpi	r28, 0x20	; 32
    1596:	d1 05       	cpc	r29, r1
    1598:	f0 f4       	brcc	.+60     	; 0x15d6 <eMBSetSlaveID+0x4a>
    {
        usMBSlaveIDLen = 0;
        ucMBSlaveID[usMBSlaveIDLen++] = ucSlaveID;
    159a:	80 93 78 03 	sts	0x0378, r24	; 0x800378 <ucMBSlaveID>
        ucMBSlaveID[usMBSlaveIDLen++] = ( UCHAR )( xIsRunning ? 0xFF : 0x00 );
    159e:	82 e0       	ldi	r24, 0x02	; 2
    15a0:	90 e0       	ldi	r25, 0x00	; 0
    15a2:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <usMBSlaveIDLen+0x1>
    15a6:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <usMBSlaveIDLen>
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	61 11       	cpse	r22, r1
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <eMBSetSlaveID+0x26>
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	81 95       	neg	r24
    15b4:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <ucMBSlaveID+0x1>
        if( usAdditionalLen > 0 )
    15b8:	21 15       	cp	r18, r1
    15ba:	31 05       	cpc	r19, r1
    15bc:	71 f0       	breq	.+28     	; 0x15da <eMBSetSlaveID+0x4e>
    15be:	ba 01       	movw	r22, r20
        {
            memcpy( &ucMBSlaveID[usMBSlaveIDLen], pucAdditional,
    15c0:	a9 01       	movw	r20, r18
    15c2:	8a e7       	ldi	r24, 0x7A	; 122
    15c4:	93 e0       	ldi	r25, 0x03	; 3
    15c6:	0e 94 e5 11 	call	0x23ca	; 0x23ca <memcpy>
                    ( size_t )usAdditionalLen );
            usMBSlaveIDLen += usAdditionalLen;
    15ca:	d0 93 77 03 	sts	0x0377, r29	; 0x800377 <usMBSlaveIDLen+0x1>
    15ce:	c0 93 76 03 	sts	0x0376, r28	; 0x800376 <usMBSlaveIDLen>

eMBErrorCode
eMBSetSlaveID( UCHAR ucSlaveID, BOOL xIsRunning,
               UCHAR const *pucAdditional, USHORT usAdditionalLen )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    15d2:	80 e0       	ldi	r24, 0x00	; 0
    15d4:	03 c0       	rjmp	.+6      	; 0x15dc <eMBSetSlaveID+0x50>
            usMBSlaveIDLen += usAdditionalLen;
        }
    }
    else
    {
        eStatus = MB_ENORES;
    15d6:	84 e0       	ldi	r24, 0x04	; 4
    15d8:	01 c0       	rjmp	.+2      	; 0x15dc <eMBSetSlaveID+0x50>

eMBErrorCode
eMBSetSlaveID( UCHAR ucSlaveID, BOOL xIsRunning,
               UCHAR const *pucAdditional, USHORT usAdditionalLen )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    15da:	80 e0       	ldi	r24, 0x00	; 0
    else
    {
        eStatus = MB_ENORES;
    }
    return eStatus;
}
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	08 95       	ret

000015e2 <eMBFuncReportSlaveID>:

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
    15e2:	0f 93       	push	r16
    15e4:	1f 93       	push	r17
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	8b 01       	movw	r16, r22
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
    15ec:	c0 91 76 03 	lds	r28, 0x0376	; 0x800376 <usMBSlaveIDLen>
    15f0:	d0 91 77 03 	lds	r29, 0x0377	; 0x800377 <usMBSlaveIDLen+0x1>
    15f4:	ae 01       	movw	r20, r28
    15f6:	68 e7       	ldi	r22, 0x78	; 120
    15f8:	73 e0       	ldi	r23, 0x03	; 3
    15fa:	01 96       	adiw	r24, 0x01	; 1
    15fc:	0e 94 e5 11 	call	0x23ca	; 0x23ca <memcpy>
    *usLen = ( USHORT )( MB_PDU_DATA_OFF + usMBSlaveIDLen );
    1600:	21 96       	adiw	r28, 0x01	; 1
    1602:	f8 01       	movw	r30, r16
    1604:	d1 83       	std	Z+1, r29	; 0x01
    1606:	c0 83       	st	Z, r28
    return MB_EX_NONE;
}
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	1f 91       	pop	r17
    1610:	0f 91       	pop	r16
    1612:	08 95       	ret

00001614 <prveMBError2Exception>:
eMBException
prveMBError2Exception( eMBErrorCode eErrorCode )
{
    eMBException    eStatus;

    switch ( eErrorCode )
    1614:	81 30       	cpi	r24, 0x01	; 1
    1616:	21 f0       	breq	.+8      	; 0x1620 <prveMBError2Exception+0xc>
    1618:	48 f0       	brcs	.+18     	; 0x162c <prveMBError2Exception+0x18>
    161a:	87 30       	cpi	r24, 0x07	; 7
    161c:	19 f0       	breq	.+6      	; 0x1624 <prveMBError2Exception+0x10>
    161e:	04 c0       	rjmp	.+8      	; 0x1628 <prveMBError2Exception+0x14>
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
            break;

        case MB_ENOREG:
            eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
    1620:	82 e0       	ldi	r24, 0x02	; 2
    1622:	08 95       	ret
            break;

        case MB_ETIMEDOUT:
            eStatus = MB_EX_SLAVE_BUSY;
    1624:	86 e0       	ldi	r24, 0x06	; 6
            break;
    1626:	08 95       	ret

        default:
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
    1628:	84 e0       	ldi	r24, 0x04	; 4
            break;
    162a:	08 95       	ret
    eMBException    eStatus;

    switch ( eErrorCode )
    {
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
    162c:	80 e0       	ldi	r24, 0x00	; 0
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
            break;
    }

    return eStatus;
}
    162e:	08 95       	ret

00001630 <eMBInit>:
    else
    {
        eStatus = MB_EILLSTATE;
    }
    return eStatus;
}
    1630:	cf 92       	push	r12
    1632:	df 92       	push	r13
    1634:	ef 92       	push	r14
    1636:	ff 92       	push	r15
    1638:	0f 93       	push	r16
    163a:	1f 93       	push	r17
    163c:	cf 93       	push	r28
    163e:	9f ef       	ldi	r25, 0xFF	; 255
    1640:	96 0f       	add	r25, r22
    1642:	97 3f       	cpi	r25, 0xF7	; 247
    1644:	08 f0       	brcs	.+2      	; 0x1648 <eMBInit+0x18>
    1646:	4b c0       	rjmp	.+150    	; 0x16de <eMBInit+0xae>
    1648:	5e 2d       	mov	r21, r14
    164a:	68 01       	movw	r12, r16
    164c:	79 01       	movw	r14, r18
    164e:	74 2f       	mov	r23, r20
    1650:	96 2f       	mov	r25, r22
    1652:	60 93 a9 03 	sts	0x03A9, r22	; 0x8003a9 <ucMBAddress>
    1656:	81 11       	cpse	r24, r1
    1658:	37 c0       	rjmp	.+110    	; 0x16c8 <eMBInit+0x98>
    165a:	2f e9       	ldi	r18, 0x9F	; 159
    165c:	3d e0       	ldi	r19, 0x0D	; 13
    165e:	30 93 a6 03 	sts	0x03A6, r19	; 0x8003a6 <pvMBFrameStartCur+0x1>
    1662:	20 93 a5 03 	sts	0x03A5, r18	; 0x8003a5 <pvMBFrameStartCur>
    1666:	2a ea       	ldi	r18, 0xAA	; 170
    1668:	3d e0       	ldi	r19, 0x0D	; 13
    166a:	30 93 a4 03 	sts	0x03A4, r19	; 0x8003a4 <pvMBFrameStopCur+0x1>
    166e:	20 93 a3 03 	sts	0x03A3, r18	; 0x8003a3 <pvMBFrameStopCur>
    1672:	2b ee       	ldi	r18, 0xEB	; 235
    1674:	3d e0       	ldi	r19, 0x0D	; 13
    1676:	30 93 a8 03 	sts	0x03A8, r19	; 0x8003a8 <peMBFrameSendCur+0x1>
    167a:	20 93 a7 03 	sts	0x03A7, r18	; 0x8003a7 <peMBFrameSendCur>
    167e:	23 eb       	ldi	r18, 0xB3	; 179
    1680:	3d e0       	ldi	r19, 0x0D	; 13
    1682:	30 93 a2 03 	sts	0x03A2, r19	; 0x8003a2 <peMBFrameReceiveCur+0x1>
    1686:	20 93 a1 03 	sts	0x03A1, r18	; 0x8003a1 <peMBFrameReceiveCur>
    168a:	10 92 a0 03 	sts	0x03A0, r1	; 0x8003a0 <pvMBFrameCloseCur+0x1>
    168e:	10 92 9f 03 	sts	0x039F, r1	; 0x80039f <pvMBFrameCloseCur>
    1692:	2b e3       	ldi	r18, 0x3B	; 59
    1694:	3e e0       	ldi	r19, 0x0E	; 14
    1696:	30 93 f2 07 	sts	0x07F2, r19	; 0x8007f2 <pxMBFrameCBByteReceived+0x1>
    169a:	20 93 f1 07 	sts	0x07F1, r18	; 0x8007f1 <pxMBFrameCBByteReceived>
    169e:	21 e9       	ldi	r18, 0x91	; 145
    16a0:	3e e0       	ldi	r19, 0x0E	; 14
    16a2:	30 93 ee 07 	sts	0x07EE, r19	; 0x8007ee <pxMBFrameCBTransmitterEmpty+0x1>
    16a6:	20 93 ed 07 	sts	0x07ED, r18	; 0x8007ed <pxMBFrameCBTransmitterEmpty>
    16aa:	2f ec       	ldi	r18, 0xCF	; 207
    16ac:	3e e0       	ldi	r19, 0x0E	; 14
    16ae:	30 93 f0 07 	sts	0x07F0, r19	; 0x8007f0 <pxMBPortCBTimerExpired+0x1>
    16b2:	20 93 ef 07 	sts	0x07EF, r18	; 0x8007ef <pxMBPortCBTimerExpired>
    16b6:	05 2f       	mov	r16, r21
    16b8:	a7 01       	movw	r20, r14
    16ba:	96 01       	movw	r18, r12
    16bc:	67 2f       	mov	r22, r23
    16be:	89 2f       	mov	r24, r25
    16c0:	0e 94 65 0d 	call	0x1aca	; 0x1aca <eMBRTUInit>
    16c4:	c8 2f       	mov	r28, r24
    16c6:	01 c0       	rjmp	.+2      	; 0x16ca <eMBInit+0x9a>
    16c8:	c2 e0       	ldi	r28, 0x02	; 2
    16ca:	c1 11       	cpse	r28, r1
    16cc:	0b c0       	rjmp	.+22     	; 0x16e4 <eMBInit+0xb4>
    16ce:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <xMBPortEventInit>
    16d2:	88 23       	and	r24, r24
    16d4:	31 f0       	breq	.+12     	; 0x16e2 <eMBInit+0xb2>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <eMBState>
    16dc:	03 c0       	rjmp	.+6      	; 0x16e4 <eMBInit+0xb4>
    16de:	c2 e0       	ldi	r28, 0x02	; 2
    16e0:	01 c0       	rjmp	.+2      	; 0x16e4 <eMBInit+0xb4>
    16e2:	c3 e0       	ldi	r28, 0x03	; 3
    16e4:	8c 2f       	mov	r24, r28
    16e6:	cf 91       	pop	r28
    16e8:	1f 91       	pop	r17
    16ea:	0f 91       	pop	r16
    16ec:	ff 90       	pop	r15
    16ee:	ef 90       	pop	r14
    16f0:	df 90       	pop	r13
    16f2:	cf 90       	pop	r12
    16f4:	08 95       	ret

000016f6 <eMBEnable>:
    16f6:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <eMBState>
    16fa:	81 30       	cpi	r24, 0x01	; 1
    16fc:	49 f4       	brne	.+18     	; 0x1710 <eMBEnable+0x1a>
    16fe:	e0 91 a5 03 	lds	r30, 0x03A5	; 0x8003a5 <pvMBFrameStartCur>
    1702:	f0 91 a6 03 	lds	r31, 0x03A6	; 0x8003a6 <pvMBFrameStartCur+0x1>
    1706:	09 95       	icall
    1708:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <eMBState>
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	08 95       	ret
    1710:	86 e0       	ldi	r24, 0x06	; 6
    1712:	08 95       	ret

00001714 <eMBPoll>:

eMBErrorCode
eMBPoll( void )
{
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	1f 92       	push	r1
    171a:	cd b7       	in	r28, 0x3d	; 61
    171c:	de b7       	in	r29, 0x3e	; 62
    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    171e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <eMBState>
    1722:	81 11       	cpse	r24, r1
    1724:	99 c0       	rjmp	.+306    	; 0x1858 <eMBPoll+0x144>
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &eEvent ) == TRUE )
    1726:	ce 01       	movw	r24, r28
    1728:	01 96       	adiw	r24, 0x01	; 1
    172a:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <xMBPortEventGet>
    172e:	81 30       	cpi	r24, 0x01	; 1
    1730:	09 f0       	breq	.+2      	; 0x1734 <eMBPoll+0x20>
    1732:	94 c0       	rjmp	.+296    	; 0x185c <eMBPoll+0x148>
    {
        switch ( eEvent )
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	81 30       	cpi	r24, 0x01	; 1
    1738:	19 f0       	breq	.+6      	; 0x1740 <eMBPoll+0x2c>
    173a:	82 30       	cpi	r24, 0x02	; 2
    173c:	d9 f0       	breq	.+54     	; 0x1774 <eMBPoll+0x60>
    173e:	90 c0       	rjmp	.+288    	; 0x1860 <eMBPoll+0x14c>
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
    1740:	e0 91 a1 03 	lds	r30, 0x03A1	; 0x8003a1 <peMBFrameReceiveCur>
    1744:	f0 91 a2 03 	lds	r31, 0x03A2	; 0x8003a2 <peMBFrameReceiveCur+0x1>
    1748:	4a e9       	ldi	r20, 0x9A	; 154
    174a:	53 e0       	ldi	r21, 0x03	; 3
    174c:	6c e9       	ldi	r22, 0x9C	; 156
    174e:	73 e0       	ldi	r23, 0x03	; 3
    1750:	8e e9       	ldi	r24, 0x9E	; 158
    1752:	93 e0       	ldi	r25, 0x03	; 3
    1754:	09 95       	icall
            if( eStatus == MB_ENOERR )
    1756:	81 11       	cpse	r24, r1
    1758:	85 c0       	rjmp	.+266    	; 0x1864 <eMBPoll+0x150>
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
    175a:	80 91 9e 03 	lds	r24, 0x039E	; 0x80039e <ucRcvAddress.2173>
    175e:	90 91 a9 03 	lds	r25, 0x03A9	; 0x8003a9 <ucMBAddress>
    1762:	89 17       	cp	r24, r25
    1764:	11 f0       	breq	.+4      	; 0x176a <eMBPoll+0x56>
    1766:	81 11       	cpse	r24, r1
    1768:	7f c0       	rjmp	.+254    	; 0x1868 <eMBPoll+0x154>
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
    176a:	82 e0       	ldi	r24, 0x02	; 2
    176c:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <xMBPortEventPost>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
    1770:	80 e0       	ldi	r24, 0x00	; 0
    1772:	80 c0       	rjmp	.+256    	; 0x1874 <eMBPoll+0x160>
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
    1774:	a0 91 9c 03 	lds	r26, 0x039C	; 0x80039c <ucMBFrame.2172>
    1778:	b0 91 9d 03 	lds	r27, 0x039D	; 0x80039d <ucMBFrame.2172+0x1>
    177c:	4c 91       	ld	r20, X
    177e:	40 93 99 03 	sts	0x0399, r20	; 0x800399 <ucFunctionCode.2174>
            eException = MB_EX_ILLEGAL_FUNCTION;
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <eException.2176>
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
    1788:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <xFuncHandlers>
    178c:	99 23       	and	r25, r25
    178e:	09 f4       	brne	.+2      	; 0x1792 <eMBPoll+0x7e>
    1790:	6d c0       	rjmp	.+218    	; 0x186c <eMBPoll+0x158>
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
    1792:	49 17       	cp	r20, r25
    1794:	59 f0       	breq	.+22     	; 0x17ac <eMBPoll+0x98>
    1796:	e7 e1       	ldi	r30, 0x17	; 23
    1798:	f1 e0       	ldi	r31, 0x01	; 1
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
    179a:	21 e0       	ldi	r18, 0x01	; 1
    179c:	30 e0       	ldi	r19, 0x00	; 0
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
    179e:	90 81       	ld	r25, Z
    17a0:	99 23       	and	r25, r25
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <eMBPoll+0x92>
    17a4:	63 c0       	rjmp	.+198    	; 0x186c <eMBPoll+0x158>
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
    17a6:	49 13       	cpse	r20, r25
    17a8:	1a c0       	rjmp	.+52     	; 0x17de <eMBPoll+0xca>
    17aa:	02 c0       	rjmp	.+4      	; 0x17b0 <eMBPoll+0x9c>
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e0       	ldi	r19, 0x00	; 0
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &usLength );
    17b0:	f9 01       	movw	r30, r18
    17b2:	ee 0f       	add	r30, r30
    17b4:	ff 1f       	adc	r31, r31
    17b6:	2e 0f       	add	r18, r30
    17b8:	3f 1f       	adc	r19, r31
    17ba:	f9 01       	movw	r30, r18
    17bc:	ec 5e       	subi	r30, 0xEC	; 236
    17be:	fe 4f       	sbci	r31, 0xFE	; 254
    17c0:	01 80       	ldd	r0, Z+1	; 0x01
    17c2:	f2 81       	ldd	r31, Z+2	; 0x02
    17c4:	e0 2d       	mov	r30, r0
    17c6:	6a e9       	ldi	r22, 0x9A	; 154
    17c8:	73 e0       	ldi	r23, 0x03	; 3
    17ca:	cd 01       	movw	r24, r26
    17cc:	09 95       	icall
    17ce:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <eException.2176>
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
    17d2:	90 91 9e 03 	lds	r25, 0x039E	; 0x80039e <ucRcvAddress.2173>
    17d6:	91 11       	cpse	r25, r1
    17d8:	09 c0       	rjmp	.+18     	; 0x17ec <eMBPoll+0xd8>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
    17da:	80 e0       	ldi	r24, 0x00	; 0
    17dc:	4b c0       	rjmp	.+150    	; 0x1874 <eMBPoll+0x160>
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
    17de:	2f 5f       	subi	r18, 0xFF	; 255
    17e0:	3f 4f       	sbci	r19, 0xFF	; 255
    17e2:	33 96       	adiw	r30, 0x03	; 3
    17e4:	20 31       	cpi	r18, 0x10	; 16
    17e6:	31 05       	cpc	r19, r1
    17e8:	d1 f6       	brne	.-76     	; 0x179e <eMBPoll+0x8a>
    17ea:	40 c0       	rjmp	.+128    	; 0x186c <eMBPoll+0x158>

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
    17ec:	88 23       	and	r24, r24
    17ee:	19 f1       	breq	.+70     	; 0x1836 <eMBPoll+0x122>
    17f0:	01 c0       	rjmp	.+2      	; 0x17f4 <eMBPoll+0xe0>
    17f2:	81 e0       	ldi	r24, 0x01	; 1
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
    17f4:	e0 91 9c 03 	lds	r30, 0x039C	; 0x80039c <ucMBFrame.2172>
    17f8:	f0 91 9d 03 	lds	r31, 0x039D	; 0x80039d <ucMBFrame.2172+0x1>
    17fc:	21 e0       	ldi	r18, 0x01	; 1
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	30 93 9b 03 	sts	0x039B, r19	; 0x80039b <usLength.2175+0x1>
    1804:	20 93 9a 03 	sts	0x039A, r18	; 0x80039a <usLength.2175>
    1808:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <ucFunctionCode.2174>
    180c:	90 68       	ori	r25, 0x80	; 128
    180e:	90 83       	st	Z, r25
                    ucMBFrame[usLength++] = eException;
    1810:	40 91 9c 03 	lds	r20, 0x039C	; 0x80039c <ucMBFrame.2172>
    1814:	50 91 9d 03 	lds	r21, 0x039D	; 0x80039d <ucMBFrame.2172+0x1>
    1818:	20 91 9a 03 	lds	r18, 0x039A	; 0x80039a <usLength.2175>
    181c:	30 91 9b 03 	lds	r19, 0x039B	; 0x80039b <usLength.2175+0x1>
    1820:	b9 01       	movw	r22, r18
    1822:	6f 5f       	subi	r22, 0xFF	; 255
    1824:	7f 4f       	sbci	r23, 0xFF	; 255
    1826:	70 93 9b 03 	sts	0x039B, r23	; 0x80039b <usLength.2175+0x1>
    182a:	60 93 9a 03 	sts	0x039A, r22	; 0x80039a <usLength.2175>
    182e:	fa 01       	movw	r30, r20
    1830:	e2 0f       	add	r30, r18
    1832:	f3 1f       	adc	r31, r19
    1834:	80 83       	st	Z, r24
                }
                if( ( eMBCurrentMode == MB_ASCII ) && MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
    1836:	40 91 9a 03 	lds	r20, 0x039A	; 0x80039a <usLength.2175>
    183a:	50 91 9b 03 	lds	r21, 0x039B	; 0x80039b <usLength.2175+0x1>
    183e:	60 91 9c 03 	lds	r22, 0x039C	; 0x80039c <ucMBFrame.2172>
    1842:	70 91 9d 03 	lds	r23, 0x039D	; 0x80039d <ucMBFrame.2172+0x1>
    1846:	e0 91 a7 03 	lds	r30, 0x03A7	; 0x8003a7 <peMBFrameSendCur>
    184a:	f0 91 a8 03 	lds	r31, 0x03A8	; 0x8003a8 <peMBFrameSendCur+0x1>
    184e:	80 91 a9 03 	lds	r24, 0x03A9	; 0x8003a9 <ucMBAddress>
    1852:	09 95       	icall

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	0e c0       	rjmp	.+28     	; 0x1874 <eMBPoll+0x160>
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
    1858:	86 e0       	ldi	r24, 0x06	; 6
    185a:	0c c0       	rjmp	.+24     	; 0x1874 <eMBPoll+0x160>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
    185c:	80 e0       	ldi	r24, 0x00	; 0
    185e:	0a c0       	rjmp	.+20     	; 0x1874 <eMBPoll+0x160>
    1860:	80 e0       	ldi	r24, 0x00	; 0
    1862:	08 c0       	rjmp	.+16     	; 0x1874 <eMBPoll+0x160>
    1864:	80 e0       	ldi	r24, 0x00	; 0
    1866:	06 c0       	rjmp	.+12     	; 0x1874 <eMBPoll+0x160>
    1868:	80 e0       	ldi	r24, 0x00	; 0
    186a:	04 c0       	rjmp	.+8      	; 0x1874 <eMBPoll+0x160>
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
    186c:	80 91 9e 03 	lds	r24, 0x039E	; 0x80039e <ucRcvAddress.2173>
    1870:	81 11       	cpse	r24, r1
    1872:	bf cf       	rjmp	.-130    	; 0x17f2 <eMBPoll+0xde>
        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
}
    1874:	0f 90       	pop	r0
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	08 95       	ret

0000187c <usMBCRC16>:
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
    187c:	61 15       	cp	r22, r1
    187e:	71 05       	cpc	r23, r1
    1880:	b9 f0       	breq	.+46     	; 0x18b0 <usMBCRC16+0x34>
    1882:	dc 01       	movw	r26, r24
    1884:	68 0f       	add	r22, r24
    1886:	79 1f       	adc	r23, r25
    1888:	9f ef       	ldi	r25, 0xFF	; 255
    188a:	4f ef       	ldi	r20, 0xFF	; 255
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
    188c:	8d 91       	ld	r24, X+
    188e:	89 27       	eor	r24, r25
    1890:	28 2f       	mov	r18, r24
    1892:	30 e0       	ldi	r19, 0x00	; 0
        ucCRCLo = ucCRCHi ^ pgm_read_byte( &aucCRCHi[iIndex] );
    1894:	f9 01       	movw	r30, r18
    1896:	e4 57       	subi	r30, 0x74	; 116
    1898:	fe 4f       	sbci	r31, 0xFE	; 254
    189a:	84 91       	lpm	r24, Z
    189c:	98 2f       	mov	r25, r24
    189e:	94 27       	eor	r25, r20
        ucCRCHi = pgm_read_byte( &aucCRCLo[iIndex] );;
    18a0:	f9 01       	movw	r30, r18
    18a2:	e4 57       	subi	r30, 0x74	; 116
    18a4:	ff 4f       	sbci	r31, 0xFF	; 255
    18a6:	44 91       	lpm	r20, Z
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    int             iIndex;

    while( usLen-- )
    18a8:	a6 17       	cp	r26, r22
    18aa:	b7 07       	cpc	r27, r23
    18ac:	79 f7       	brne	.-34     	; 0x188c <usMBCRC16+0x10>
    18ae:	02 c0       	rjmp	.+4      	; 0x18b4 <usMBCRC16+0x38>

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucCRCHi = 0xFF;
    UCHAR           ucCRCLo = 0xFF;
    18b0:	9f ef       	ldi	r25, 0xFF	; 255
};

USHORT
usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR           ucCRCHi = 0xFF;
    18b2:	4f ef       	ldi	r20, 0xFF	; 255
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ucCRCHi ^ pgm_read_byte( &aucCRCHi[iIndex] );
        ucCRCHi = pgm_read_byte( &aucCRCLo[iIndex] );;
    }
    return ucCRCHi << 8 | ucCRCLo;
    18b4:	89 2f       	mov	r24, r25
    18b6:	90 e0       	ldi	r25, 0x00	; 0
}
    18b8:	94 2b       	or	r25, r20
    18ba:	08 95       	ret

000018bc <xMBPortEventInit>:

/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortEventInit( void )
{
    xEventInQueue = FALSE;
    18bc:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <xEventInQueue>
    return TRUE;
}
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	08 95       	ret

000018c4 <xMBPortEventPost>:

BOOL
xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = TRUE;
    18c4:	91 e0       	ldi	r25, 0x01	; 1
    18c6:	90 93 aa 03 	sts	0x03AA, r25	; 0x8003aa <xEventInQueue>
    eQueuedEvent = eEvent;
    18ca:	80 93 ab 03 	sts	0x03AB, r24	; 0x8003ab <eQueuedEvent>
    return TRUE;
}
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	08 95       	ret

000018d2 <xMBPortEventGet>:

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    18d2:	fc 01       	movw	r30, r24
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    18d4:	90 91 aa 03 	lds	r25, 0x03AA	; 0x8003aa <xEventInQueue>
    18d8:	99 23       	and	r25, r25
    18da:	39 f0       	breq	.+14     	; 0x18ea <xMBPortEventGet+0x18>
    {
        *eEvent = eQueuedEvent;
    18dc:	80 91 ab 03 	lds	r24, 0x03AB	; 0x8003ab <eQueuedEvent>
    18e0:	80 83       	st	Z, r24
        xEventInQueue = FALSE;
    18e2:	10 92 aa 03 	sts	0x03AA, r1	; 0x8003aa <xEventInQueue>
        xEventHappened = TRUE;
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	08 95       	ret
}

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;
    18ea:	80 e0       	ldi	r24, 0x00	; 0
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    return xEventHappened;
}
    18ec:	08 95       	ret

000018ee <vMBPortSerialEnable>:
vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
{
#ifdef RTS_ENABLE
    UCSRB |= _BV( TXEN ) | _BV(TXCIE);
#else
    UCSRB |= _BV( TXEN );
    18ee:	53 9a       	sbi	0x0a, 3	; 10
#endif

    if( xRxEnable )
    18f0:	88 23       	and	r24, r24
    18f2:	21 f0       	breq	.+8      	; 0x18fc <vMBPortSerialEnable+0xe>
    {
        UCSRB |= _BV( RXEN ) | _BV( RXCIE );
    18f4:	8a b1       	in	r24, 0x0a	; 10
    18f6:	80 69       	ori	r24, 0x90	; 144
    18f8:	8a b9       	out	0x0a, r24	; 10
    18fa:	03 c0       	rjmp	.+6      	; 0x1902 <vMBPortSerialEnable+0x14>
    }
    else
    {
        UCSRB &= ~( _BV( RXEN ) | _BV( RXCIE ) );
    18fc:	8a b1       	in	r24, 0x0a	; 10
    18fe:	8f 76       	andi	r24, 0x6F	; 111
    1900:	8a b9       	out	0x0a, r24	; 10
    }

    if( xTxEnable )
    1902:	66 23       	and	r22, r22
    1904:	21 f0       	breq	.+8      	; 0x190e <vMBPortSerialEnable+0x20>
    {
        UCSRB |= _BV( TXEN ) | _BV( UDRE );
    1906:	8a b1       	in	r24, 0x0a	; 10
    1908:	88 62       	ori	r24, 0x28	; 40
    190a:	8a b9       	out	0x0a, r24	; 10
    190c:	08 95       	ret
        RTS_HIGH;
#endif
    }
    else
    {
        UCSRB &= ~( _BV( UDRE ) );
    190e:	55 98       	cbi	0x0a, 5	; 10
    1910:	08 95       	ret

00001912 <xMBPortSerialInit>:
    UCHAR ucUCSRC = 0;

    /* prevent compiler warning. */
    (void)ucPORT;
	
    UBRR = UART_BAUD_CALC( ulBaudRate, F_CPU );
    1912:	db 01       	movw	r26, r22
    1914:	ca 01       	movw	r24, r20
    1916:	88 0f       	add	r24, r24
    1918:	99 1f       	adc	r25, r25
    191a:	aa 1f       	adc	r26, r26
    191c:	bb 1f       	adc	r27, r27
    191e:	88 0f       	add	r24, r24
    1920:	99 1f       	adc	r25, r25
    1922:	aa 1f       	adc	r26, r26
    1924:	bb 1f       	adc	r27, r27
    1926:	9c 01       	movw	r18, r24
    1928:	ad 01       	movw	r20, r26
    192a:	22 0f       	add	r18, r18
    192c:	33 1f       	adc	r19, r19
    192e:	44 1f       	adc	r20, r20
    1930:	55 1f       	adc	r21, r21
    1932:	22 0f       	add	r18, r18
    1934:	33 1f       	adc	r19, r19
    1936:	44 1f       	adc	r20, r20
    1938:	55 1f       	adc	r21, r21
    193a:	60 e0       	ldi	r22, 0x00	; 0
    193c:	70 e8       	ldi	r23, 0x80	; 128
    193e:	80 e7       	ldi	r24, 0x70	; 112
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	0e 94 b4 11 	call	0x2368	; 0x2368 <__udivmodsi4>
    1946:	21 50       	subi	r18, 0x01	; 1
    1948:	29 b9       	out	0x09, r18	; 9
    UCSRC = _BV( URSEL ) | ucUCSRC;
#elif defined (__AVR_ATmega128__)
    UCSRC |= ucUCSRC;
#endif

    vMBPortSerialEnable( FALSE, FALSE );
    194a:	60 e0       	ldi	r22, 0x00	; 0
    194c:	80 e0       	ldi	r24, 0x00	; 0
    194e:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>

#ifdef RTS_ENABLE
    RTS_INIT;
#endif
    return TRUE;
}
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	08 95       	ret

00001956 <xMBPortSerialPutByte>:

BOOL
xMBPortSerialPutByte( CHAR ucByte )
{
    UDR = ucByte;
    1956:	8c b9       	out	0x0c, r24	; 12
    return TRUE;
}
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	08 95       	ret

0000195c <xMBPortSerialGetByte>:

BOOL
xMBPortSerialGetByte( CHAR * pucByte )
{
    *pucByte = UDR;
    195c:	2c b1       	in	r18, 0x0c	; 12
    195e:	fc 01       	movw	r30, r24
    1960:	20 83       	st	Z, r18
    return TRUE;
}
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	08 95       	ret

00001966 <__vector_19>:


ISR(USART0_UDRE_vect){
    1966:	1f 92       	push	r1
    1968:	0f 92       	push	r0
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	0f 92       	push	r0
    196e:	11 24       	eor	r1, r1
    1970:	2f 93       	push	r18
    1972:	3f 93       	push	r19
    1974:	4f 93       	push	r20
    1976:	5f 93       	push	r21
    1978:	6f 93       	push	r22
    197a:	7f 93       	push	r23
    197c:	8f 93       	push	r24
    197e:	9f 93       	push	r25
    1980:	af 93       	push	r26
    1982:	bf 93       	push	r27
    1984:	ef 93       	push	r30
    1986:	ff 93       	push	r31
	pxMBFrameCBTransmitterEmpty(  );
    1988:	e0 91 ed 07 	lds	r30, 0x07ED	; 0x8007ed <pxMBFrameCBTransmitterEmpty>
    198c:	f0 91 ee 07 	lds	r31, 0x07EE	; 0x8007ee <pxMBFrameCBTransmitterEmpty+0x1>
    1990:	09 95       	icall
}
    1992:	ff 91       	pop	r31
    1994:	ef 91       	pop	r30
    1996:	bf 91       	pop	r27
    1998:	af 91       	pop	r26
    199a:	9f 91       	pop	r25
    199c:	8f 91       	pop	r24
    199e:	7f 91       	pop	r23
    19a0:	6f 91       	pop	r22
    19a2:	5f 91       	pop	r21
    19a4:	4f 91       	pop	r20
    19a6:	3f 91       	pop	r19
    19a8:	2f 91       	pop	r18
    19aa:	0f 90       	pop	r0
    19ac:	0f be       	out	0x3f, r0	; 63
    19ae:	0f 90       	pop	r0
    19b0:	1f 90       	pop	r1
    19b2:	18 95       	reti

000019b4 <__vector_18>:


/*
 * Temporarily disconnected..for Wimod interface debugging..
 */ 
ISR(USART0_RX_vect){
    19b4:	1f 92       	push	r1
    19b6:	0f 92       	push	r0
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	0f 92       	push	r0
    19bc:	11 24       	eor	r1, r1
    19be:	2f 93       	push	r18
    19c0:	3f 93       	push	r19
    19c2:	4f 93       	push	r20
    19c4:	5f 93       	push	r21
    19c6:	6f 93       	push	r22
    19c8:	7f 93       	push	r23
    19ca:	8f 93       	push	r24
    19cc:	9f 93       	push	r25
    19ce:	af 93       	push	r26
    19d0:	bf 93       	push	r27
    19d2:	ef 93       	push	r30
    19d4:	ff 93       	push	r31
	pxMBFrameCBByteReceived(  );
    19d6:	e0 91 f1 07 	lds	r30, 0x07F1	; 0x8007f1 <pxMBFrameCBByteReceived>
    19da:	f0 91 f2 07 	lds	r31, 0x07F2	; 0x8007f2 <pxMBFrameCBByteReceived+0x1>
    19de:	09 95       	icall
}
    19e0:	ff 91       	pop	r31
    19e2:	ef 91       	pop	r30
    19e4:	bf 91       	pop	r27
    19e6:	af 91       	pop	r26
    19e8:	9f 91       	pop	r25
    19ea:	8f 91       	pop	r24
    19ec:	7f 91       	pop	r23
    19ee:	6f 91       	pop	r22
    19f0:	5f 91       	pop	r21
    19f2:	4f 91       	pop	r20
    19f4:	3f 91       	pop	r19
    19f6:	2f 91       	pop	r18
    19f8:	0f 90       	pop	r0
    19fa:	0f be       	out	0x3f, r0	; 63
    19fc:	0f 90       	pop	r0
    19fe:	1f 90       	pop	r1
    1a00:	18 95       	reti

00001a02 <xMBPortTimersInit>:
/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortTimersInit( USHORT usTim1Timerout50us )
{
    /* Calculate overflow counter an OCR values for Timer1. */
    usTimerOCRADelta =
    1a02:	9c 01       	movw	r18, r24
    1a04:	a0 e2       	ldi	r26, 0x20	; 32
    1a06:	bc e1       	ldi	r27, 0x1C	; 28
    1a08:	0e 94 d6 11 	call	0x23ac	; 0x23ac <__umulhisi3>
    1a0c:	20 e2       	ldi	r18, 0x20	; 32
    1a0e:	3e e4       	ldi	r19, 0x4E	; 78
    1a10:	40 e0       	ldi	r20, 0x00	; 0
    1a12:	50 e0       	ldi	r21, 0x00	; 0
    1a14:	0e 94 b4 11 	call	0x2368	; 0x2368 <__udivmodsi4>
    1a18:	30 93 ad 03 	sts	0x03AD, r19	; 0x8003ad <usTimerOCRADelta+0x1>
    1a1c:	20 93 ac 03 	sts	0x03AC, r18	; 0x8003ac <usTimerOCRADelta>
        ( MB_TIMER_TICKS * usTim1Timerout50us ) / ( MB_50US_TICKS );

    TCCR1A = 0x00;
    1a20:	1f bc       	out	0x2f, r1	; 47
    TCCR1B = 0x00;
    1a22:	1e bc       	out	0x2e, r1	; 46
    TCCR1C = 0x00;
    1a24:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

inline void
vMBPortTimersDisable(  )
{
    /* Disable the timer. */
    TCCR1B &= ~( _BV( CS12 ) | _BV( CS10 ) );
    1a28:	8e b5       	in	r24, 0x2e	; 46
    1a2a:	8a 7f       	andi	r24, 0xFA	; 250
    1a2c:	8e bd       	out	0x2e, r24	; 46
    /* Disable the output compare interrupts for channel A/B. */
    TIMSK1 &= ~( _BV( OCIE1A ) );
    1a2e:	87 b7       	in	r24, 0x37	; 55
    1a30:	8f 7e       	andi	r24, 0xEF	; 239
    1a32:	87 bf       	out	0x37, r24	; 55
    /* Clear output compare flags for channel A/B. */
    TIFR1 |= _BV( OCF1A ) ;
    1a34:	86 b7       	in	r24, 0x36	; 54
    1a36:	80 61       	ori	r24, 0x10	; 16
    1a38:	86 bf       	out	0x36, r24	; 54
    TCCR1C = 0x00;

    vMBPortTimersDisable(  );

    return TRUE;
}
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	08 95       	ret

00001a3e <vMBPortTimersEnable>:


inline void
vMBPortTimersEnable(  )
{
    TCNT1 = 0x0000;
    1a3e:	1d bc       	out	0x2d, r1	; 45
    1a40:	1c bc       	out	0x2c, r1	; 44
    if( usTimerOCRADelta > 0 )
    1a42:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <usTimerOCRADelta>
    1a46:	90 91 ad 03 	lds	r25, 0x03AD	; 0x8003ad <usTimerOCRADelta+0x1>
    1a4a:	89 2b       	or	r24, r25
    1a4c:	49 f0       	breq	.+18     	; 0x1a60 <vMBPortTimersEnable+0x22>
    {
        TIMSK1 |= _BV( OCIE1A );
    1a4e:	87 b7       	in	r24, 0x37	; 55
    1a50:	80 61       	ori	r24, 0x10	; 16
    1a52:	87 bf       	out	0x37, r24	; 55
        OCR1A = usTimerOCRADelta;
    1a54:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <usTimerOCRADelta>
    1a58:	90 91 ad 03 	lds	r25, 0x03AD	; 0x8003ad <usTimerOCRADelta+0x1>
    1a5c:	9b bd       	out	0x2b, r25	; 43
    1a5e:	8a bd       	out	0x2a, r24	; 42
    }

    TCCR1B |= _BV( CS12 ) | _BV( CS10 );
    1a60:	8e b5       	in	r24, 0x2e	; 46
    1a62:	85 60       	ori	r24, 0x05	; 5
    1a64:	8e bd       	out	0x2e, r24	; 46
    1a66:	08 95       	ret

00001a68 <vMBPortTimersDisable>:

inline void
vMBPortTimersDisable(  )
{
    /* Disable the timer. */
    TCCR1B &= ~( _BV( CS12 ) | _BV( CS10 ) );
    1a68:	8e b5       	in	r24, 0x2e	; 46
    1a6a:	8a 7f       	andi	r24, 0xFA	; 250
    1a6c:	8e bd       	out	0x2e, r24	; 46
    /* Disable the output compare interrupts for channel A/B. */
    TIMSK1 &= ~( _BV( OCIE1A ) );
    1a6e:	87 b7       	in	r24, 0x37	; 55
    1a70:	8f 7e       	andi	r24, 0xEF	; 239
    1a72:	87 bf       	out	0x37, r24	; 55
    /* Clear output compare flags for channel A/B. */
    TIFR1 |= _BV( OCF1A ) ;
    1a74:	86 b7       	in	r24, 0x36	; 54
    1a76:	80 61       	ori	r24, 0x10	; 16
    1a78:	86 bf       	out	0x36, r24	; 54
    1a7a:	08 95       	ret

00001a7c <__vector_12>:
}

/* SIG_OUTPUT_COMPARE1A */
SIGNAL( TIMER1_COMPA_vect )
{
    1a7c:	1f 92       	push	r1
    1a7e:	0f 92       	push	r0
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	0f 92       	push	r0
    1a84:	11 24       	eor	r1, r1
    1a86:	2f 93       	push	r18
    1a88:	3f 93       	push	r19
    1a8a:	4f 93       	push	r20
    1a8c:	5f 93       	push	r21
    1a8e:	6f 93       	push	r22
    1a90:	7f 93       	push	r23
    1a92:	8f 93       	push	r24
    1a94:	9f 93       	push	r25
    1a96:	af 93       	push	r26
    1a98:	bf 93       	push	r27
    1a9a:	ef 93       	push	r30
    1a9c:	ff 93       	push	r31
    ( void )pxMBPortCBTimerExpired(  );
    1a9e:	e0 91 ef 07 	lds	r30, 0x07EF	; 0x8007ef <pxMBPortCBTimerExpired>
    1aa2:	f0 91 f0 07 	lds	r31, 0x07F0	; 0x8007f0 <pxMBPortCBTimerExpired+0x1>
    1aa6:	09 95       	icall
}
    1aa8:	ff 91       	pop	r31
    1aaa:	ef 91       	pop	r30
    1aac:	bf 91       	pop	r27
    1aae:	af 91       	pop	r26
    1ab0:	9f 91       	pop	r25
    1ab2:	8f 91       	pop	r24
    1ab4:	7f 91       	pop	r23
    1ab6:	6f 91       	pop	r22
    1ab8:	5f 91       	pop	r21
    1aba:	4f 91       	pop	r20
    1abc:	3f 91       	pop	r19
    1abe:	2f 91       	pop	r18
    1ac0:	0f 90       	pop	r0
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	0f 90       	pop	r0
    1ac6:	1f 90       	pop	r1
    1ac8:	18 95       	reti

00001aca <eMBRTUInit>:
static volatile USHORT usRcvBufferPos;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    1aca:	cf 92       	push	r12
    1acc:	df 92       	push	r13
    1ace:	ef 92       	push	r14
    1ad0:	ff 92       	push	r15
    1ad2:	0f 93       	push	r16
    1ad4:	86 2f       	mov	r24, r22
    1ad6:	69 01       	movw	r12, r18
    1ad8:	7a 01       	movw	r14, r20
    eMBErrorCode    eStatus = MB_ENOERR;
    ULONG           usTimerT35_50us;

    ( void )ucSlaveAddress;
    ENTER_CRITICAL_SECTION(  );
    1ada:	f8 94       	cli

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
    1adc:	28 e0       	ldi	r18, 0x08	; 8
    1ade:	b7 01       	movw	r22, r14
    1ae0:	a6 01       	movw	r20, r12
    1ae2:	0e 94 89 0c 	call	0x1912	; 0x1912 <xMBPortSerialInit>
    1ae6:	81 30       	cpi	r24, 0x01	; 1
    1ae8:	01 f5       	brne	.+64     	; 0x1b2a <eMBRTUInit+0x60>
    else
    {
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
    1aea:	81 e0       	ldi	r24, 0x01	; 1
    1aec:	c8 16       	cp	r12, r24
    1aee:	8b e4       	ldi	r24, 0x4B	; 75
    1af0:	d8 06       	cpc	r13, r24
    1af2:	e1 04       	cpc	r14, r1
    1af4:	f1 04       	cpc	r15, r1
    1af6:	78 f4       	brcc	.+30     	; 0x1b16 <eMBRTUInit+0x4c>
             *             = 11 * Ticks_per_1s / Baudrate
             *             = 220000 / Baudrate
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
    1af8:	a7 01       	movw	r20, r14
    1afa:	96 01       	movw	r18, r12
    1afc:	22 0f       	add	r18, r18
    1afe:	33 1f       	adc	r19, r19
    1b00:	44 1f       	adc	r20, r20
    1b02:	55 1f       	adc	r21, r21
    1b04:	60 ea       	ldi	r22, 0xA0	; 160
    1b06:	7f e7       	ldi	r23, 0x7F	; 127
    1b08:	87 e1       	ldi	r24, 0x17	; 23
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	0e 94 b4 11 	call	0x2368	; 0x2368 <__udivmodsi4>
    1b10:	da 01       	movw	r26, r20
    1b12:	c9 01       	movw	r24, r18
    1b14:	04 c0       	rjmp	.+8      	; 0x1b1e <eMBRTUInit+0x54>
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
        {
            usTimerT35_50us = 35;       /* 1800us. */
    1b16:	83 e2       	ldi	r24, 0x23	; 35
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	a0 e0       	ldi	r26, 0x00	; 0
    1b1c:	b0 e0       	ldi	r27, 0x00	; 0
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
    1b1e:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <xMBPortTimersInit>
    1b22:	81 30       	cpi	r24, 0x01	; 1
    1b24:	21 f0       	breq	.+8      	; 0x1b2e <eMBRTUInit+0x64>
        {
            eStatus = MB_EPORTERR;
    1b26:	83 e0       	ldi	r24, 0x03	; 3
    1b28:	03 c0       	rjmp	.+6      	; 0x1b30 <eMBRTUInit+0x66>
    ENTER_CRITICAL_SECTION(  );

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
    {
        eStatus = MB_EPORTERR;
    1b2a:	83 e0       	ldi	r24, 0x03	; 3
    1b2c:	01 c0       	rjmp	.+2      	; 0x1b30 <eMBRTUInit+0x66>

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    1b2e:	80 e0       	ldi	r24, 0x00	; 0
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
        {
            eStatus = MB_EPORTERR;
        }
    }
    EXIT_CRITICAL_SECTION(  );
    1b30:	78 94       	sei

    return eStatus;
}
    1b32:	0f 91       	pop	r16
    1b34:	ff 90       	pop	r15
    1b36:	ef 90       	pop	r14
    1b38:	df 90       	pop	r13
    1b3a:	cf 90       	pop	r12
    1b3c:	08 95       	ret

00001b3e <eMBRTUStart>:

void
eMBRTUStart( void )
{
    ENTER_CRITICAL_SECTION(  );
    1b3e:	f8 94       	cli
    /* Initially the receiver is in the state STATE_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_RX_INIT;
    1b40:	10 92 b4 03 	sts	0x03B4, r1	; 0x8003b4 <eRcvState>
    vMBPortSerialEnable( TRUE, FALSE );
    1b44:	60 e0       	ldi	r22, 0x00	; 0
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>
    vMBPortTimersEnable(  );
    1b4c:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vMBPortTimersEnable>

    EXIT_CRITICAL_SECTION(  );
    1b50:	78 94       	sei
    1b52:	08 95       	ret

00001b54 <eMBRTUStop>:
}

void
eMBRTUStop( void )
{
    ENTER_CRITICAL_SECTION(  );
    1b54:	f8 94       	cli
    vMBPortSerialEnable( FALSE, FALSE );
    1b56:	60 e0       	ldi	r22, 0x00	; 0
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>
    vMBPortTimersDisable(  );
    1b5e:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <vMBPortTimersDisable>
    EXIT_CRITICAL_SECTION(  );
    1b62:	78 94       	sei
    1b64:	08 95       	ret

00001b66 <eMBRTUReceive>:
}

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
    1b66:	ef 92       	push	r14
    1b68:	ff 92       	push	r15
    1b6a:	0f 93       	push	r16
    1b6c:	1f 93       	push	r17
    1b6e:	cf 93       	push	r28
    1b70:	df 93       	push	r29
    BOOL            xFrameReceived = FALSE;
    eMBErrorCode    eStatus = MB_ENOERR;

    ENTER_CRITICAL_SECTION(  );
    1b72:	f8 94       	cli
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
    1b74:	20 91 ae 03 	lds	r18, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1b78:	30 91 af 03 	lds	r19, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1b7c:	24 30       	cpi	r18, 0x04	; 4
    1b7e:	31 05       	cpc	r19, r1
    1b80:	f8 f0       	brcs	.+62     	; 0x1bc0 <eMBRTUReceive+0x5a>
    1b82:	7a 01       	movw	r14, r20
    1b84:	8b 01       	movw	r16, r22
    1b86:	ec 01       	movw	r28, r24
        && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
    1b88:	60 91 ae 03 	lds	r22, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1b8c:	70 91 af 03 	lds	r23, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1b90:	87 ef       	ldi	r24, 0xF7	; 247
    1b92:	97 e0       	ldi	r25, 0x07	; 7
    1b94:	0e 94 3e 0c 	call	0x187c	; 0x187c <usMBCRC16>
    1b98:	89 2b       	or	r24, r25
    1b9a:	a1 f4       	brne	.+40     	; 0x1bc4 <eMBRTUReceive+0x5e>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
    1b9c:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <ucRTUBuf>
    1ba0:	88 83       	st	Y, r24

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
    1ba2:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1ba6:	90 91 af 03 	lds	r25, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1baa:	03 97       	sbiw	r24, 0x03	; 3
    1bac:	f7 01       	movw	r30, r14
    1bae:	91 83       	std	Z+1, r25	; 0x01
    1bb0:	80 83       	st	Z, r24

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
    1bb2:	88 ef       	ldi	r24, 0xF8	; 248
    1bb4:	97 e0       	ldi	r25, 0x07	; 7
    1bb6:	f8 01       	movw	r30, r16
    1bb8:	91 83       	std	Z+1, r25	; 0x01
    1bba:	80 83       	st	Z, r24

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
    BOOL            xFrameReceived = FALSE;
    eMBErrorCode    eStatus = MB_ENOERR;
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
        xFrameReceived = TRUE;
    1bbe:	03 c0       	rjmp	.+6      	; 0x1bc6 <eMBRTUReceive+0x60>
    }
    else
    {
        eStatus = MB_EIO;
    1bc0:	85 e0       	ldi	r24, 0x05	; 5
    1bc2:	01 c0       	rjmp	.+2      	; 0x1bc6 <eMBRTUReceive+0x60>
    1bc4:	85 e0       	ldi	r24, 0x05	; 5
    }

    EXIT_CRITICAL_SECTION(  );
    1bc6:	78 94       	sei
    return eStatus;
}
    1bc8:	df 91       	pop	r29
    1bca:	cf 91       	pop	r28
    1bcc:	1f 91       	pop	r17
    1bce:	0f 91       	pop	r16
    1bd0:	ff 90       	pop	r15
    1bd2:	ef 90       	pop	r14
    1bd4:	08 95       	ret

00001bd6 <eMBRTUSend>:
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    ENTER_CRITICAL_SECTION(  );
    1bd6:	f8 94       	cli

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
    1bd8:	90 91 b4 03 	lds	r25, 0x03B4	; 0x8003b4 <eRcvState>
    1bdc:	91 30       	cpi	r25, 0x01	; 1
    1bde:	09 f0       	breq	.+2      	; 0x1be2 <eMBRTUSend+0xc>
    1be0:	47 c0       	rjmp	.+142    	; 0x1c70 <eMBRTUSend+0x9a>
    1be2:	28 2f       	mov	r18, r24
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
    1be4:	cb 01       	movw	r24, r22
    1be6:	01 97       	sbiw	r24, 0x01	; 1
    1be8:	90 93 b3 03 	sts	0x03B3, r25	; 0x8003b3 <pucSndBufferCur+0x1>
    1bec:	80 93 b2 03 	sts	0x03B2, r24	; 0x8003b2 <pucSndBufferCur>
        usSndBufferCount = 1;
    1bf0:	61 e0       	ldi	r22, 0x01	; 1
    1bf2:	70 e0       	ldi	r23, 0x00	; 0
    1bf4:	70 93 b1 03 	sts	0x03B1, r23	; 0x8003b1 <usSndBufferCount+0x1>
    1bf8:	60 93 b0 03 	sts	0x03B0, r22	; 0x8003b0 <usSndBufferCount>

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	20 83       	st	Z, r18
        usSndBufferCount += usLength;
    1c00:	20 91 b0 03 	lds	r18, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1c04:	30 91 b1 03 	lds	r19, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1c08:	42 0f       	add	r20, r18
    1c0a:	53 1f       	adc	r21, r19
    1c0c:	50 93 b1 03 	sts	0x03B1, r21	; 0x8003b1 <usSndBufferCount+0x1>
    1c10:	40 93 b0 03 	sts	0x03B0, r20	; 0x8003b0 <usSndBufferCount>

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
    1c14:	60 91 b0 03 	lds	r22, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1c18:	70 91 b1 03 	lds	r23, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1c1c:	0e 94 3e 0c 	call	0x187c	; 0x187c <usMBCRC16>
    1c20:	49 2f       	mov	r20, r25
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
    1c22:	20 91 b0 03 	lds	r18, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1c26:	30 91 b1 03 	lds	r19, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1c2a:	b9 01       	movw	r22, r18
    1c2c:	6f 5f       	subi	r22, 0xFF	; 255
    1c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c30:	70 93 b1 03 	sts	0x03B1, r23	; 0x8003b1 <usSndBufferCount+0x1>
    1c34:	60 93 b0 03 	sts	0x03B0, r22	; 0x8003b0 <usSndBufferCount>
    1c38:	f9 01       	movw	r30, r18
    1c3a:	e9 50       	subi	r30, 0x09	; 9
    1c3c:	f8 4f       	sbci	r31, 0xF8	; 248
    1c3e:	80 83       	st	Z, r24
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
    1c40:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1c44:	90 91 b1 03 	lds	r25, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1c48:	9c 01       	movw	r18, r24
    1c4a:	2f 5f       	subi	r18, 0xFF	; 255
    1c4c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c4e:	30 93 b1 03 	sts	0x03B1, r19	; 0x8003b1 <usSndBufferCount+0x1>
    1c52:	20 93 b0 03 	sts	0x03B0, r18	; 0x8003b0 <usSndBufferCount>
    1c56:	fc 01       	movw	r30, r24
    1c58:	e9 50       	subi	r30, 0x09	; 9
    1c5a:	f8 4f       	sbci	r31, 0xF8	; 248
    1c5c:	40 83       	st	Z, r20

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	80 93 b5 03 	sts	0x03B5, r24	; 0x8003b5 <eSndState>
        vMBPortSerialEnable( FALSE, TRUE );
    1c64:	61 e0       	ldi	r22, 0x01	; 1
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>
}

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    1c6c:	80 e0       	ldi	r24, 0x00	; 0
    1c6e:	01 c0       	rjmp	.+2      	; 0x1c72 <eMBRTUSend+0x9c>
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
    1c70:	85 e0       	ldi	r24, 0x05	; 5
    }
    EXIT_CRITICAL_SECTION(  );
    1c72:	78 94       	sei
    return eStatus;
}
    1c74:	08 95       	ret

00001c76 <xMBRTUReceiveFSM>:

BOOL
xMBRTUReceiveFSM( void )
{
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	1f 92       	push	r1
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );

    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
    1c80:	ce 01       	movw	r24, r28
    1c82:	01 96       	adiw	r24, 0x01	; 1
    1c84:	0e 94 ae 0c 	call	0x195c	; 0x195c <xMBPortSerialGetByte>

    switch ( eRcvState )
    1c88:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <eRcvState>
    1c8c:	81 30       	cpi	r24, 0x01	; 1
    1c8e:	61 f0       	breq	.+24     	; 0x1ca8 <xMBRTUReceiveFSM+0x32>
    1c90:	28 f0       	brcs	.+10     	; 0x1c9c <xMBRTUReceiveFSM+0x26>
    1c92:	82 30       	cpi	r24, 0x02	; 2
    1c94:	19 f1       	breq	.+70     	; 0x1cdc <xMBRTUReceiveFSM+0x66>
    1c96:	83 30       	cpi	r24, 0x03	; 3
    1c98:	21 f0       	breq	.+8      	; 0x1ca2 <xMBRTUReceiveFSM+0x2c>
    1c9a:	3e c0       	rjmp	.+124    	; 0x1d18 <xMBRTUReceiveFSM+0xa2>
    {
        /* If we have received a character in the init state we have to
         * wait until the frame is finished.
         */
    case STATE_RX_INIT:
        vMBPortTimersEnable(  );
    1c9c:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vMBPortTimersEnable>
        break;
    1ca0:	3b c0       	rjmp	.+118    	; 0x1d18 <xMBRTUReceiveFSM+0xa2>

        /* In the error state we wait until all characters in the
         * damaged frame are transmitted.
         */
    case STATE_RX_ERROR:
        vMBPortTimersEnable(  );
    1ca2:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vMBPortTimersEnable>
        break;
    1ca6:	38 c0       	rjmp	.+112    	; 0x1d18 <xMBRTUReceiveFSM+0xa2>
        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
    1ca8:	10 92 af 03 	sts	0x03AF, r1	; 0x8003af <usRcvBufferPos+0x1>
    1cac:	10 92 ae 03 	sts	0x03AE, r1	; 0x8003ae <usRcvBufferPos>
        ucRTUBuf[usRcvBufferPos++] = ucByte;
    1cb0:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1cb4:	90 91 af 03 	lds	r25, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1cb8:	9c 01       	movw	r18, r24
    1cba:	2f 5f       	subi	r18, 0xFF	; 255
    1cbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cbe:	30 93 af 03 	sts	0x03AF, r19	; 0x8003af <usRcvBufferPos+0x1>
    1cc2:	20 93 ae 03 	sts	0x03AE, r18	; 0x8003ae <usRcvBufferPos>
    1cc6:	29 81       	ldd	r18, Y+1	; 0x01
    1cc8:	fc 01       	movw	r30, r24
    1cca:	e9 50       	subi	r30, 0x09	; 9
    1ccc:	f8 4f       	sbci	r31, 0xF8	; 248
    1cce:	20 83       	st	Z, r18
        eRcvState = STATE_RX_RCV;
    1cd0:	82 e0       	ldi	r24, 0x02	; 2
    1cd2:	80 93 b4 03 	sts	0x03B4, r24	; 0x8003b4 <eRcvState>

        /* Enable t3.5 timers. */
        vMBPortTimersEnable(  );
    1cd6:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vMBPortTimersEnable>
        break;
    1cda:	1e c0       	rjmp	.+60     	; 0x1d18 <xMBRTUReceiveFSM+0xa2>
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
    1cdc:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1ce0:	90 91 af 03 	lds	r25, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1ce4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce6:	91 05       	cpc	r25, r1
    1ce8:	09 f0       	breq	.+2      	; 0x1cec <xMBRTUReceiveFSM+0x76>
    1cea:	88 f4       	brcc	.+34     	; 0x1d0e <xMBRTUReceiveFSM+0x98>
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
    1cec:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <usRcvBufferPos>
    1cf0:	90 91 af 03 	lds	r25, 0x03AF	; 0x8003af <usRcvBufferPos+0x1>
    1cf4:	9c 01       	movw	r18, r24
    1cf6:	2f 5f       	subi	r18, 0xFF	; 255
    1cf8:	3f 4f       	sbci	r19, 0xFF	; 255
    1cfa:	30 93 af 03 	sts	0x03AF, r19	; 0x8003af <usRcvBufferPos+0x1>
    1cfe:	20 93 ae 03 	sts	0x03AE, r18	; 0x8003ae <usRcvBufferPos>
    1d02:	29 81       	ldd	r18, Y+1	; 0x01
    1d04:	fc 01       	movw	r30, r24
    1d06:	e9 50       	subi	r30, 0x09	; 9
    1d08:	f8 4f       	sbci	r31, 0xF8	; 248
    1d0a:	20 83       	st	Z, r18
    1d0c:	03 c0       	rjmp	.+6      	; 0x1d14 <xMBRTUReceiveFSM+0x9e>
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
    1d0e:	83 e0       	ldi	r24, 0x03	; 3
    1d10:	80 93 b4 03 	sts	0x03B4, r24	; 0x8003b4 <eRcvState>
        }
        vMBPortTimersEnable(  );
    1d14:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vMBPortTimersEnable>
        break;
    }
    return xTaskNeedSwitch;
}
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	0f 90       	pop	r0
    1d1c:	df 91       	pop	r29
    1d1e:	cf 91       	pop	r28
    1d20:	08 95       	ret

00001d22 <xMBRTUTransmitFSM>:

BOOL
xMBRTUTransmitFSM( void )
{
    1d22:	cf 93       	push	r28
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
    1d24:	80 91 b5 03 	lds	r24, 0x03B5	; 0x8003b5 <eSndState>
    1d28:	88 23       	and	r24, r24
    1d2a:	19 f0       	breq	.+6      	; 0x1d32 <xMBRTUTransmitFSM+0x10>
    1d2c:	81 30       	cpi	r24, 0x01	; 1
    1d2e:	39 f0       	breq	.+14     	; 0x1d3e <xMBRTUTransmitFSM+0x1c>
    1d30:	32 c0       	rjmp	.+100    	; 0x1d96 <xMBRTUTransmitFSM+0x74>
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
    1d32:	60 e0       	ldi	r22, 0x00	; 0
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
    1d3a:	c0 e0       	ldi	r28, 0x00	; 0
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;
    1d3c:	2d c0       	rjmp	.+90     	; 0x1d98 <xMBRTUTransmitFSM+0x76>

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
    1d3e:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1d42:	90 91 b1 03 	lds	r25, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1d46:	89 2b       	or	r24, r25
    1d48:	d9 f0       	breq	.+54     	; 0x1d80 <xMBRTUTransmitFSM+0x5e>
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
    1d4a:	e0 91 b2 03 	lds	r30, 0x03B2	; 0x8003b2 <pucSndBufferCur>
    1d4e:	f0 91 b3 03 	lds	r31, 0x03B3	; 0x8003b3 <pucSndBufferCur+0x1>
    1d52:	80 81       	ld	r24, Z
    1d54:	0e 94 ab 0c 	call	0x1956	; 0x1956 <xMBPortSerialPutByte>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
    1d58:	80 91 b2 03 	lds	r24, 0x03B2	; 0x8003b2 <pucSndBufferCur>
    1d5c:	90 91 b3 03 	lds	r25, 0x03B3	; 0x8003b3 <pucSndBufferCur+0x1>
    1d60:	01 96       	adiw	r24, 0x01	; 1
    1d62:	90 93 b3 03 	sts	0x03B3, r25	; 0x8003b3 <pucSndBufferCur+0x1>
    1d66:	80 93 b2 03 	sts	0x03B2, r24	; 0x8003b2 <pucSndBufferCur>
            usSndBufferCount--;
    1d6a:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <usSndBufferCount>
    1d6e:	90 91 b1 03 	lds	r25, 0x03B1	; 0x8003b1 <usSndBufferCount+0x1>
    1d72:	01 97       	sbiw	r24, 0x01	; 1
    1d74:	90 93 b1 03 	sts	0x03B1, r25	; 0x8003b1 <usSndBufferCount+0x1>
    1d78:	80 93 b0 03 	sts	0x03B0, r24	; 0x8003b0 <usSndBufferCount>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
    1d7c:	c0 e0       	ldi	r28, 0x00	; 0
    1d7e:	0c c0       	rjmp	.+24     	; 0x1d98 <xMBRTUTransmitFSM+0x76>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
            usSndBufferCount--;
        }
        else
        {
            xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
    1d80:	83 e0       	ldi	r24, 0x03	; 3
    1d82:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <xMBPortEventPost>
    1d86:	c8 2f       	mov	r28, r24
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBPortSerialEnable( TRUE, FALSE );
    1d88:	60 e0       	ldi	r22, 0x00	; 0
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	0e 94 77 0c 	call	0x18ee	; 0x18ee <vMBPortSerialEnable>
            eSndState = STATE_TX_IDLE;
    1d90:	10 92 b5 03 	sts	0x03B5, r1	; 0x8003b5 <eSndState>
    1d94:	01 c0       	rjmp	.+2      	; 0x1d98 <xMBRTUTransmitFSM+0x76>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
    1d96:	c0 e0       	ldi	r28, 0x00	; 0
        }
        break;
    }

    return xNeedPoll;
}
    1d98:	8c 2f       	mov	r24, r28
    1d9a:	cf 91       	pop	r28
    1d9c:	08 95       	ret

00001d9e <xMBRTUTimerT35Expired>:

BOOL
xMBRTUTimerT35Expired( void )
{
    1d9e:	cf 93       	push	r28
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
    1da0:	80 91 b4 03 	lds	r24, 0x03B4	; 0x8003b4 <eRcvState>
    1da4:	88 23       	and	r24, r24
    1da6:	19 f0       	breq	.+6      	; 0x1dae <xMBRTUTimerT35Expired+0x10>
    1da8:	82 30       	cpi	r24, 0x02	; 2
    1daa:	31 f0       	breq	.+12     	; 0x1db8 <xMBRTUTimerT35Expired+0x1a>
    1dac:	0a c0       	rjmp	.+20     	; 0x1dc2 <xMBRTUTimerT35Expired+0x24>
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <xMBPortEventPost>
    1db4:	c8 2f       	mov	r28, r24
        break;
    1db6:	06 c0       	rjmp	.+12     	; 0x1dc4 <xMBRTUTimerT35Expired+0x26>

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
    1db8:	81 e0       	ldi	r24, 0x01	; 1
    1dba:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <xMBPortEventPost>
    1dbe:	c8 2f       	mov	r28, r24
        break;
    1dc0:	01 c0       	rjmp	.+2      	; 0x1dc4 <xMBRTUTimerT35Expired+0x26>
}

BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;
    1dc2:	c0 e0       	ldi	r28, 0x00	; 0
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
    1dc4:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <vMBPortTimersDisable>
    eRcvState = STATE_RX_IDLE;
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	80 93 b4 03 	sts	0x03B4, r24	; 0x8003b4 <eRcvState>

    return xNeedPoll;
}
    1dce:	8c 2f       	mov	r24, r28
    1dd0:	cf 91       	pop	r28
    1dd2:	08 95       	ret

00001dd4 <BufferIn>:
	uint8_t count;
	} buffer = {{}, 0, 0, 0};

	uint8_t BufferIn(uint8_t byte)
	{
		uint8_t next = ((buffer.write + 1) & BUFFER_MASK);
    1dd4:	e0 91 37 04 	lds	r30, 0x0437	; 0x800437 <buffer+0x81>
    1dd8:	91 e0       	ldi	r25, 0x01	; 1
    1dda:	9e 0f       	add	r25, r30
    1ddc:	9f 77       	andi	r25, 0x7F	; 127
		if (buffer.read == next)
    1dde:	20 91 36 04 	lds	r18, 0x0436	; 0x800436 <buffer+0x80>
    1de2:	92 17       	cp	r25, r18
    1de4:	69 f0       	breq	.+26     	; 0x1e00 <BufferIn+0x2c>
			return FAIL;
		buffer.data[buffer.write] = byte;
    1de6:	f0 e0       	ldi	r31, 0x00	; 0
    1de8:	ea 54       	subi	r30, 0x4A	; 74
    1dea:	fc 4f       	sbci	r31, 0xFC	; 252
    1dec:	80 83       	st	Z, r24
		// buffer.data[buffer.write & BUFFER_MASK] = byte; // absolut Sicher
		buffer.write = next;
    1dee:	90 93 37 04 	sts	0x0437, r25	; 0x800437 <buffer+0x81>
		buffer.count++;
    1df2:	e8 e3       	ldi	r30, 0x38	; 56
    1df4:	f4 e0       	ldi	r31, 0x04	; 4
    1df6:	80 81       	ld	r24, Z
    1df8:	8f 5f       	subi	r24, 0xFF	; 255
    1dfa:	80 83       	st	Z, r24
		return SUCCESS;
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	08 95       	ret

	uint8_t BufferIn(uint8_t byte)
	{
		uint8_t next = ((buffer.write + 1) & BUFFER_MASK);
		if (buffer.read == next)
			return FAIL;
    1e00:	80 e0       	ldi	r24, 0x00	; 0
		buffer.data[buffer.write] = byte;
		// buffer.data[buffer.write & BUFFER_MASK] = byte; // absolut Sicher
		buffer.write = next;
		buffer.count++;
		return SUCCESS;
	}
    1e02:	08 95       	ret

00001e04 <spi_init>:
 */ 
#include "SPI.h"

void spi_init(){
	// Assign output pins. MISO stays input pin.
	DDRB = (1 << DD_MOSI) 
    1e04:	87 e0       	ldi	r24, 0x07	; 7
    1e06:	87 bb       	out	0x17, r24	; 23
		| (1 << DD_SCK)
		| (1 << DD_SS0);
	
	DDRC = (1 << DD_SS1)
    1e08:	8e ef       	ldi	r24, 0xFE	; 254
    1e0a:	84 bb       	out	0x14, r24	; 20
		| (1 << DD_SS4)
		| (1 << DD_SS5)
		| (1 << DD_SS6)
		| (1 << DD_SS7);
		
	SPCR = (1 << SPE) // enable SPI 
    1e0c:	84 e5       	ldi	r24, 0x54	; 84
    1e0e:	8d b9       	out	0x0d, r24	; 13
		| (1 << MSTR) // set master
		| (1 << CPHA); // CPHA - Clock Phase = 1; CPOL - Clock Polarity = 0   ==> Sampling on falling edge
		
	// SPI clock rate: Neither SPR0, SPR1 nor SPI2X are set in SPCR => f_sck = f_osc/4
	
	PORTB |= (1 << DD_SS0);
    1e10:	c0 9a       	sbi	0x18, 0	; 24
	// Set all slave selection pins to 0
	PORTC |= ( (1 << DD_SS1) | (1 << DD_SS2) | (1 << DD_SS3) | (1 << DD_SS4)  | (1 << DD_SS5) | (1 << DD_SS6) | (1 << DD_SS7) );
    1e12:	85 b3       	in	r24, 0x15	; 21
    1e14:	8e 6f       	ori	r24, 0xFE	; 254
    1e16:	85 bb       	out	0x15, r24	; 21
    1e18:	08 95       	ret

00001e1a <spi_rx16_adc_portc>:
uint16_t spi_rx16_adc_portc(uint8_t ss)
{
	uint16_t adc_data;
	
	// Set slave selection bit
	PORTC &= ~(1 << ss);
    1e1a:	95 b3       	in	r25, 0x15	; 21
    1e1c:	21 e0       	ldi	r18, 0x01	; 1
    1e1e:	30 e0       	ldi	r19, 0x00	; 0
    1e20:	02 c0       	rjmp	.+4      	; 0x1e26 <spi_rx16_adc_portc+0xc>
    1e22:	22 0f       	add	r18, r18
    1e24:	33 1f       	adc	r19, r19
    1e26:	8a 95       	dec	r24
    1e28:	e2 f7       	brpl	.-8      	; 0x1e22 <spi_rx16_adc_portc+0x8>
    1e2a:	82 2f       	mov	r24, r18
    1e2c:	80 95       	com	r24
    1e2e:	98 23       	and	r25, r24
    1e30:	95 bb       	out	0x15, r25	; 21
	
	// Write dummy byte to request 
	SPDR = 0x00;
    1e32:	1f b8       	out	0x0f, r1	; 15
	
	// Receive MSB
	while(!(SPSR & (1 << SPIF)));
    1e34:	77 9b       	sbis	0x0e, 7	; 14
    1e36:	fe cf       	rjmp	.-4      	; 0x1e34 <spi_rx16_adc_portc+0x1a>
	adc_data = SPDR;
    1e38:	8f b1       	in	r24, 0x0f	; 15
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
	adc_data <<= 8;
    1e3c:	98 2f       	mov	r25, r24
    1e3e:	88 27       	eor	r24, r24
	
	SPDR = 0x00;
    1e40:	1f b8       	out	0x0f, r1	; 15
	
	// Receive LSB
	while(!(SPSR & (1 << SPIF)));
    1e42:	77 9b       	sbis	0x0e, 7	; 14
    1e44:	fe cf       	rjmp	.-4      	; 0x1e42 <spi_rx16_adc_portc+0x28>
	// Combine [MSB,xxx] + [LSB] = [MSB,LSB]
	adc_data |= SPDR;
    1e46:	3f b1       	in	r19, 0x0f	; 15
	
	// Reset the slave selection bit. End of packet.
	PORTC |= (1 << ss);
    1e48:	45 b3       	in	r20, 0x15	; 21
    1e4a:	24 2b       	or	r18, r20
    1e4c:	25 bb       	out	0x15, r18	; 21
	
	return adc_data;
}
    1e4e:	83 2b       	or	r24, r19
    1e50:	08 95       	ret

00001e52 <spi_rx16_adc_portb>:
uint16_t spi_rx16_adc_portb(uint8_t ss)
{	
	uint16_t adc_data;
	
	// Set slave selection bit
	PORTB &= ~(1 << ss);
    1e52:	98 b3       	in	r25, 0x18	; 24
    1e54:	21 e0       	ldi	r18, 0x01	; 1
    1e56:	30 e0       	ldi	r19, 0x00	; 0
    1e58:	02 c0       	rjmp	.+4      	; 0x1e5e <spi_rx16_adc_portb+0xc>
    1e5a:	22 0f       	add	r18, r18
    1e5c:	33 1f       	adc	r19, r19
    1e5e:	8a 95       	dec	r24
    1e60:	e2 f7       	brpl	.-8      	; 0x1e5a <spi_rx16_adc_portb+0x8>
    1e62:	82 2f       	mov	r24, r18
    1e64:	80 95       	com	r24
    1e66:	98 23       	and	r25, r24
    1e68:	98 bb       	out	0x18, r25	; 24
	
	// Write dummy byte to request
	SPDR = 0x00;
    1e6a:	1f b8       	out	0x0f, r1	; 15
	
	// Receive MSB
	while(!(SPSR & (1 << SPIF)));
    1e6c:	77 9b       	sbis	0x0e, 7	; 14
    1e6e:	fe cf       	rjmp	.-4      	; 0x1e6c <spi_rx16_adc_portb+0x1a>
	adc_data = SPDR;
    1e70:	8f b1       	in	r24, 0x0f	; 15
    1e72:	90 e0       	ldi	r25, 0x00	; 0
	adc_data <<= 8;
    1e74:	98 2f       	mov	r25, r24
    1e76:	88 27       	eor	r24, r24
	
	SPDR = 0x00;
    1e78:	1f b8       	out	0x0f, r1	; 15
	
	// Receive LSB
	while(!(SPSR & (1 << SPIF)));
    1e7a:	77 9b       	sbis	0x0e, 7	; 14
    1e7c:	fe cf       	rjmp	.-4      	; 0x1e7a <spi_rx16_adc_portb+0x28>
	// Combine [MSB,xxx] + [LSB] = [MSB,LSB]
	adc_data |= SPDR;
    1e7e:	3f b1       	in	r19, 0x0f	; 15
	
	// Reset the slave selection bit. End of packet.
	PORTB |= (1 << ss);
    1e80:	48 b3       	in	r20, 0x18	; 24
    1e82:	24 2b       	or	r18, r20
    1e84:	28 bb       	out	0x18, r18	; 24
	
	return adc_data;
    1e86:	83 2b       	or	r24, r19
    1e88:	08 95       	ret

00001e8a <uart0_tx_byte>:
}


void uart0_tx_byte(unsigned char *byte){
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );/* Put data into buffer, sends the data */
    1e8a:	5d 9b       	sbis	0x0b, 5	; 11
    1e8c:	fe cf       	rjmp	.-4      	; 0x1e8a <uart0_tx_byte>
	UDR0 = *byte;
    1e8e:	fc 01       	movw	r30, r24
    1e90:	80 81       	ld	r24, Z
    1e92:	8c b9       	out	0x0c, r24	; 12
    1e94:	08 95       	ret

00001e96 <uart0_tx_packet>:
}

void uart0_tx_packet(unsigned char *data, size_t bytes)
{
    1e96:	0f 93       	push	r16
    1e98:	1f 93       	push	r17
    1e9a:	cf 93       	push	r28
    1e9c:	df 93       	push	r29
	int i;
	// Reading that is big endian (most significant byte is sent first)
	for(i=0; i < bytes; i++){
    1e9e:	61 15       	cp	r22, r1
    1ea0:	71 05       	cpc	r23, r1
    1ea2:	59 f0       	breq	.+22     	; 0x1eba <uart0_tx_packet+0x24>
    1ea4:	8c 01       	movw	r16, r24
    1ea6:	ec 01       	movw	r28, r24
    1ea8:	06 0f       	add	r16, r22
    1eaa:	17 1f       	adc	r17, r23
		uart0_tx_byte(&data[i]);
    1eac:	ce 01       	movw	r24, r28
    1eae:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <uart0_tx_byte>
    1eb2:	21 96       	adiw	r28, 0x01	; 1

void uart0_tx_packet(unsigned char *data, size_t bytes)
{
	int i;
	// Reading that is big endian (most significant byte is sent first)
	for(i=0; i < bytes; i++){
    1eb4:	0c 17       	cp	r16, r28
    1eb6:	1d 07       	cpc	r17, r29
    1eb8:	c9 f7       	brne	.-14     	; 0x1eac <uart0_tx_packet+0x16>
		uart0_tx_byte(&data[i]);
	}
}
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	1f 91       	pop	r17
    1ec0:	0f 91       	pop	r16
    1ec2:	08 95       	ret

00001ec4 <uart1_init>:


void uart1_init(int ubrr)
{
	/* Set baud rate */
	UBRR1H = (unsigned char)(ubrr>>8);
    1ec4:	90 93 98 00 	sts	0x0098, r25	; 0x800098 <__DATA_REGION_ORIGIN__+0x38>
	UBRR1L = (unsigned char)ubrr;/* Enable receiver and transmitter */
    1ec8:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__DATA_REGION_ORIGIN__+0x39>
	UCSR1A = (1<<U2X1);
    1ecc:	82 e0       	ldi	r24, 0x02	; 2
    1ece:	80 93 9b 00 	sts	0x009B, r24	; 0x80009b <__DATA_REGION_ORIGIN__+0x3b>
	UCSR1B = (1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1);/* Set frame format: 8data, 1stop bit */
    1ed2:	88 e9       	ldi	r24, 0x98	; 152
    1ed4:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__DATA_REGION_ORIGIN__+0x3a>
	UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
    1ed8:	86 e0       	ldi	r24, 0x06	; 6
    1eda:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__DATA_REGION_ORIGIN__+0x3d>
    1ede:	08 95       	ret

00001ee0 <uart1_tx_byte>:
}


void uart1_tx_byte(unsigned char * byte)
{
    1ee0:	dc 01       	movw	r26, r24
	/* Wait for empty transmit buffer */
	while ( !( UCSR1A & (1<<UDRE1)) );/* Put data into buffer, sends the data */
    1ee2:	eb e9       	ldi	r30, 0x9B	; 155
    1ee4:	f0 e0       	ldi	r31, 0x00	; 0
    1ee6:	90 81       	ld	r25, Z
    1ee8:	95 ff       	sbrs	r25, 5
    1eea:	fd cf       	rjmp	.-6      	; 0x1ee6 <uart1_tx_byte+0x6>
	UDR1 = *byte;
    1eec:	8c 91       	ld	r24, X
    1eee:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <__DATA_REGION_ORIGIN__+0x3c>
    1ef2:	08 95       	ret

00001ef4 <uart1_tx_packet>:
}


int uart1_tx_packet(unsigned char *data, size_t bytes)
{
    1ef4:	ef 92       	push	r14
    1ef6:	ff 92       	push	r15
    1ef8:	0f 93       	push	r16
    1efa:	1f 93       	push	r17
    1efc:	cf 93       	push	r28
    1efe:	df 93       	push	r29
	int i;
	for(i=0; i < bytes; i++){
    1f00:	61 15       	cp	r22, r1
    1f02:	71 05       	cpc	r23, r1
    1f04:	79 f0       	breq	.+30     	; 0x1f24 <uart1_tx_packet+0x30>
    1f06:	7b 01       	movw	r14, r22
    1f08:	8c 01       	movw	r16, r24
    1f0a:	ec 01       	movw	r28, r24
    1f0c:	06 0f       	add	r16, r22
    1f0e:	17 1f       	adc	r17, r23
		uart1_tx_byte(&data[i]);
    1f10:	ce 01       	movw	r24, r28
    1f12:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <uart1_tx_byte>
    1f16:	21 96       	adiw	r28, 0x01	; 1


int uart1_tx_packet(unsigned char *data, size_t bytes)
{
	int i;
	for(i=0; i < bytes; i++){
    1f18:	c0 17       	cp	r28, r16
    1f1a:	d1 07       	cpc	r29, r17
    1f1c:	c9 f7       	brne	.-14     	; 0x1f10 <uart1_tx_packet+0x1c>
    1f1e:	8e 2d       	mov	r24, r14
    1f20:	9f 2d       	mov	r25, r15
    1f22:	02 c0       	rjmp	.+4      	; 0x1f28 <uart1_tx_packet+0x34>
    1f24:	80 e0       	ldi	r24, 0x00	; 0
    1f26:	90 e0       	ldi	r25, 0x00	; 0
		uart1_tx_byte(&data[i]);
	}
	return i;
}
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	ff 90       	pop	r15
    1f32:	ef 90       	pop	r14
    1f34:	08 95       	ret

00001f36 <CRC16_Calc>:
			 {
				 // init crc
				 UINT16		crc = initVal;
				 
				 // iterate over all bytes
				 while(length--)
    1f36:	61 15       	cp	r22, r1
    1f38:	71 05       	cpc	r23, r1
    1f3a:	a1 f0       	breq	.+40     	; 0x1f64 <CRC16_Calc+0x2e>
    1f3c:	dc 01       	movw	r26, r24
    1f3e:	68 0f       	add	r22, r24
    1f40:	79 1f       	adc	r23, r25
				 {
					 // calc new crc
					 crc = (crc >> 8) ^ CRC16_Table[(crc ^ *data++) & 0x00FF];
    1f42:	25 2f       	mov	r18, r21
    1f44:	33 27       	eor	r19, r19
    1f46:	9d 91       	ld	r25, X+
    1f48:	fa 01       	movw	r30, r20
    1f4a:	e9 27       	eor	r30, r25
    1f4c:	ff 27       	eor	r31, r31
    1f4e:	ee 0f       	add	r30, r30
    1f50:	ff 1f       	adc	r31, r31
    1f52:	e1 5b       	subi	r30, 0xB1	; 177
    1f54:	fe 4f       	sbci	r31, 0xFE	; 254
    1f56:	40 81       	ld	r20, Z
    1f58:	51 81       	ldd	r21, Z+1	; 0x01
    1f5a:	42 27       	eor	r20, r18
    1f5c:	53 27       	eor	r21, r19
			 {
				 // init crc
				 UINT16		crc = initVal;
				 
				 // iterate over all bytes
				 while(length--)
    1f5e:	a6 17       	cp	r26, r22
    1f60:	b7 07       	cpc	r27, r23
    1f62:	79 f7       	brne	.-34     	; 0x1f42 <CRC16_Calc+0xc>
					 crc = (crc >> 8) ^ CRC16_Table[(crc ^ *data++) & 0x00FF];
				 }
				 
				 // return result
				 return crc;
			 }
    1f64:	ca 01       	movw	r24, r20
    1f66:	08 95       	ret

00001f68 <CRC16_Check>:
CRC16_Check	(UINT8*					data,
			 UINT16					length,
			 UINT16					initVal)
			 {
				 // calc ones complement of CRC16
				 UINT16 crc = ~CRC16_Calc(data, length, initVal);
    1f68:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <CRC16_Calc>
				 // CRC ok ?
				 return (bool)(crc == CRC16_GOOD_VALUE);
    1f6c:	21 e0       	ldi	r18, 0x01	; 1
    1f6e:	88 3b       	cpi	r24, 0xB8	; 184
    1f70:	90 4f       	sbci	r25, 0xF0	; 240
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <CRC16_Check+0xe>
    1f74:	20 e0       	ldi	r18, 0x00	; 0
			 }
    1f76:	82 2f       	mov	r24, r18
    1f78:	08 95       	ret

00001f7a <SLIP_StoreTxByte>:
		break;

		default:
		break;
	}
}
    1f7a:	e9 e3       	ldi	r30, 0x39	; 57
    1f7c:	f4 e0       	ldi	r31, 0x04	; 4
    1f7e:	22 85       	ldd	r18, Z+10	; 0x0a
    1f80:	33 85       	ldd	r19, Z+11	; 0x0b
    1f82:	44 85       	ldd	r20, Z+12	; 0x0c
    1f84:	55 85       	ldd	r21, Z+13	; 0x0d
    1f86:	24 17       	cp	r18, r20
    1f88:	35 07       	cpc	r19, r21
    1f8a:	5c f4       	brge	.+22     	; 0x1fa2 <SLIP_StoreTxByte+0x28>
    1f8c:	46 85       	ldd	r20, Z+14	; 0x0e
    1f8e:	57 85       	ldd	r21, Z+15	; 0x0f
    1f90:	b9 01       	movw	r22, r18
    1f92:	6f 5f       	subi	r22, 0xFF	; 255
    1f94:	7f 4f       	sbci	r23, 0xFF	; 255
    1f96:	73 87       	std	Z+11, r23	; 0x0b
    1f98:	62 87       	std	Z+10, r22	; 0x0a
    1f9a:	fa 01       	movw	r30, r20
    1f9c:	e2 0f       	add	r30, r18
    1f9e:	f3 1f       	adc	r31, r19
    1fa0:	80 83       	st	Z, r24
    1fa2:	08 95       	ret

00001fa4 <SLIP_Init>:
    1fa4:	e9 e3       	ldi	r30, 0x39	; 57
    1fa6:	f4 e0       	ldi	r31, 0x04	; 4
    1fa8:	11 82       	std	Z+1, r1	; 0x01
    1faa:	10 82       	st	Z, r1
    1fac:	13 82       	std	Z+3, r1	; 0x03
    1fae:	12 82       	std	Z+2, r1	; 0x02
    1fb0:	17 82       	std	Z+7, r1	; 0x07
    1fb2:	16 82       	std	Z+6, r1	; 0x06
    1fb4:	15 82       	std	Z+5, r1	; 0x05
    1fb6:	14 82       	std	Z+4, r1	; 0x04
    1fb8:	91 87       	std	Z+9, r25	; 0x09
    1fba:	80 87       	std	Z+8, r24	; 0x08
    1fbc:	13 86       	std	Z+11, r1	; 0x0b
    1fbe:	12 86       	std	Z+10, r1	; 0x0a
    1fc0:	17 86       	std	Z+15, r1	; 0x0f
    1fc2:	16 86       	std	Z+14, r1	; 0x0e
    1fc4:	15 86       	std	Z+13, r1	; 0x0d
    1fc6:	14 86       	std	Z+12, r1	; 0x0c
    1fc8:	08 95       	ret

00001fca <SLIP_SetRxBuffer>:
    1fca:	20 91 39 04 	lds	r18, 0x0439	; 0x800439 <SLIP>
    1fce:	30 91 3a 04 	lds	r19, 0x043A	; 0x80043a <SLIP+0x1>
    1fd2:	23 2b       	or	r18, r19
    1fd4:	89 f4       	brne	.+34     	; 0x1ff8 <SLIP_SetRxBuffer+0x2e>
    1fd6:	20 91 41 04 	lds	r18, 0x0441	; 0x800441 <SLIP+0x8>
    1fda:	30 91 42 04 	lds	r19, 0x0442	; 0x800442 <SLIP+0x9>
    1fde:	23 2b       	or	r18, r19
    1fe0:	69 f0       	breq	.+26     	; 0x1ffc <SLIP_SetRxBuffer+0x32>
    1fe2:	e9 e3       	ldi	r30, 0x39	; 57
    1fe4:	f4 e0       	ldi	r31, 0x04	; 4
    1fe6:	97 83       	std	Z+7, r25	; 0x07
    1fe8:	86 83       	std	Z+6, r24	; 0x06
    1fea:	75 83       	std	Z+5, r23	; 0x05
    1fec:	64 83       	std	Z+4, r22	; 0x04
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	91 83       	std	Z+1, r25	; 0x01
    1ff4:	80 83       	st	Z, r24
    1ff6:	08 95       	ret
    1ff8:	80 e0       	ldi	r24, 0x00	; 0
    1ffa:	08 95       	ret
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	08 95       	ret

00002000 <SLIP_EncodeData>:
// 
//------------------------------------------------------------------------------

int
SLIP_EncodeData(UINT8* dstBuffer, int dstBufferSize, UINT8* srcData, int srcLength)
{
    2000:	0f 93       	push	r16
    2002:	1f 93       	push	r17
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	ea 01       	movw	r28, r20
    200a:	89 01       	movw	r16, r18
	
	// save start pointer
	int txLength = 0;
	
	// init TxBuffer
	SLIP.TxBuffer = dstBuffer;
    200c:	e9 e3       	ldi	r30, 0x39	; 57
    200e:	f4 e0       	ldi	r31, 0x04	; 4
    2010:	97 87       	std	Z+15, r25	; 0x0f
    2012:	86 87       	std	Z+14, r24	; 0x0e
	
	// init TxIndex
	SLIP.TxIndex = 0;
    2014:	13 86       	std	Z+11, r1	; 0x0b
    2016:	12 86       	std	Z+10, r1	; 0x0a
	
	// init size
	SLIP.TxBufferSize = dstBufferSize;
    2018:	75 87       	std	Z+13, r23	; 0x0d
    201a:	64 87       	std	Z+12, r22	; 0x0c
	
	// send start of SLIP message
	SLIP_StoreTxByte(SLIP_END);
    201c:	80 ec       	ldi	r24, 0xC0	; 192
    201e:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
	
	// iterate over all message bytes
	while(srcLength--)
    2022:	01 15       	cp	r16, r1
    2024:	11 05       	cpc	r17, r1
    2026:	d1 f0       	breq	.+52     	; 0x205c <SLIP_EncodeData+0x5c>
	{
		switch(*srcData)
    2028:	88 81       	ld	r24, Y
    202a:	80 3c       	cpi	r24, 0xC0	; 192
    202c:	19 f0       	breq	.+6      	; 0x2034 <SLIP_EncodeData+0x34>
    202e:	8b 3d       	cpi	r24, 0xDB	; 219
    2030:	41 f0       	breq	.+16     	; 0x2042 <SLIP_EncodeData+0x42>
    2032:	0d c0       	rjmp	.+26     	; 0x204e <SLIP_EncodeData+0x4e>
             * receiver think we sent an END
			 * 
			 * -- Why should this happen at all?
             */
			case SLIP_END:
				SLIP_StoreTxByte(SLIP_ESC);
    2034:	8b ed       	ldi	r24, 0xDB	; 219
    2036:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
				SLIP_StoreTxByte(SLIP_ESC_END);
    203a:	8c ed       	ldi	r24, 0xDC	; 220
    203c:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
				break;
    2040:	09 c0       	rjmp	.+18     	; 0x2054 <SLIP_EncodeData+0x54>
			 * to make the receiver think we sent an ESC
			 * 
			 * -- Why should this happen at all?
			 */
			case SLIP_ESC:
				SLIP_StoreTxByte(SLIP_ESC);
    2042:	8b ed       	ldi	r24, 0xDB	; 219
    2044:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
				SLIP_StoreTxByte(SLIP_ESC_ESC);
    2048:	8d ed       	ldi	r24, 0xDD	; 221
    204a:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
			default:
				SLIP_StoreTxByte(*srcData);
    204e:	88 81       	ld	r24, Y
    2050:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
				break;
		}
		//next byte
		srcData++;
    2054:	21 96       	adiw	r28, 0x01	; 1
    2056:	01 50       	subi	r16, 0x01	; 1
    2058:	11 09       	sbc	r17, r1
	
	// send start of SLIP message
	SLIP_StoreTxByte(SLIP_END);
	
	// iterate over all message bytes
	while(srcLength--)
    205a:	31 f7       	brne	.-52     	; 0x2028 <SLIP_EncodeData+0x28>
		//next byte
		srcData++;
	}
	
	// send end of SLIP message
	SLIP_StoreTxByte(SLIP_END);
    205c:	80 ec       	ldi	r24, 0xC0	; 192
    205e:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <SLIP_StoreTxByte>
	
	// length ok ?
	if(SLIP.TxIndex <= SLIP.TxBufferSize)
    2062:	e9 e3       	ldi	r30, 0x39	; 57
    2064:	f4 e0       	ldi	r31, 0x04	; 4
    2066:	82 85       	ldd	r24, Z+10	; 0x0a
    2068:	93 85       	ldd	r25, Z+11	; 0x0b
    206a:	24 85       	ldd	r18, Z+12	; 0x0c
    206c:	35 85       	ldd	r19, Z+13	; 0x0d
    206e:	28 17       	cp	r18, r24
    2070:	39 07       	cpc	r19, r25
    2072:	14 f4       	brge	.+4      	; 0x2078 <SLIP_EncodeData+0x78>
		return SLIP.TxIndex;
	
	// return tx length error
	return -1;
    2074:	8f ef       	ldi	r24, 0xFF	; 255
    2076:	9f ef       	ldi	r25, 0xFF	; 255
    2078:	df 91       	pop	r29
    207a:	cf 91       	pop	r28
    207c:	1f 91       	pop	r17
    207e:	0f 91       	pop	r16
    2080:	08 95       	ret

00002082 <WiMOD_HCI_ProcessRxMessage>:

			//  reset the serial rx buffer with memset or similar..
			//  Because this function will most likely be called in a while loop
			memset(rxBuf, 0, sizeof(*rxBuf));
		}
}
    2082:	0f 93       	push	r16
    2084:	1f 93       	push	r17
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
    208a:	64 30       	cpi	r22, 0x04	; 4
    208c:	71 05       	cpc	r23, r1
    208e:	64 f1       	brlt	.+88     	; 0x20e8 <WiMOD_HCI_ProcessRxMessage+0x66>
    2090:	eb 01       	movw	r28, r22
    2092:	4f ef       	ldi	r20, 0xFF	; 255
    2094:	5f ef       	ldi	r21, 0xFF	; 255
    2096:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <CRC16_Check>
    209a:	88 23       	and	r24, r24
    209c:	c1 f0       	breq	.+48     	; 0x20ce <WiMOD_HCI_ProcessRxMessage+0x4c>
    209e:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <HCI+0x6>
    20a2:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <HCI+0x7>
    20a6:	30 97       	sbiw	r30, 0x00	; 0
    20a8:	f9 f0       	breq	.+62     	; 0x20e8 <WiMOD_HCI_ProcessRxMessage+0x66>
    20aa:	0f ea       	ldi	r16, 0xAF	; 175
    20ac:	16 e0       	ldi	r17, 0x06	; 6
    20ae:	d8 01       	movw	r26, r16
    20b0:	14 96       	adiw	r26, 0x04	; 4
    20b2:	8d 91       	ld	r24, X+
    20b4:	9c 91       	ld	r25, X
    20b6:	15 97       	sbiw	r26, 0x05	; 5
    20b8:	be 01       	movw	r22, r28
    20ba:	64 50       	subi	r22, 0x04	; 4
    20bc:	71 09       	sbc	r23, r1
    20be:	dc 01       	movw	r26, r24
    20c0:	6d 93       	st	X+, r22
    20c2:	7c 93       	st	X, r23
    20c4:	09 95       	icall
    20c6:	f8 01       	movw	r30, r16
    20c8:	95 83       	std	Z+5, r25	; 0x05
    20ca:	84 83       	std	Z+4, r24	; 0x04
    20cc:	0d c0       	rjmp	.+26     	; 0x20e8 <WiMOD_HCI_ProcessRxMessage+0x66>
    20ce:	ef ea       	ldi	r30, 0xAF	; 175
    20d0:	f6 e0       	ldi	r31, 0x06	; 6
    20d2:	80 81       	ld	r24, Z
    20d4:	91 81       	ldd	r25, Z+1	; 0x01
    20d6:	a2 81       	ldd	r26, Z+2	; 0x02
    20d8:	b3 81       	ldd	r27, Z+3	; 0x03
    20da:	01 96       	adiw	r24, 0x01	; 1
    20dc:	a1 1d       	adc	r26, r1
    20de:	b1 1d       	adc	r27, r1
    20e0:	80 83       	st	Z, r24
    20e2:	91 83       	std	Z+1, r25	; 0x01
    20e4:	a2 83       	std	Z+2, r26	; 0x02
    20e6:	b3 83       	std	Z+3, r27	; 0x03
    20e8:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <HCI+0x4>
    20ec:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <HCI+0x5>
    20f0:	00 97       	sbiw	r24, 0x00	; 0
    20f2:	11 f0       	breq	.+4      	; 0x20f8 <WiMOD_HCI_ProcessRxMessage+0x76>
    20f4:	02 96       	adiw	r24, 0x02	; 2
    20f6:	02 c0       	rjmp	.+4      	; 0x20fc <WiMOD_HCI_ProcessRxMessage+0x7a>
    20f8:	80 e0       	ldi	r24, 0x00	; 0
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	df 91       	pop	r29
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	08 95       	ret

00002106 <WiMOD_HCI_Init>:
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	ea 01       	movw	r28, r20
    210c:	ef ea       	ldi	r30, 0xAF	; 175
    210e:	f6 e0       	ldi	r31, 0x06	; 6
    2110:	10 82       	st	Z, r1
    2112:	11 82       	std	Z+1, r1	; 0x01
    2114:	12 82       	std	Z+2, r1	; 0x02
    2116:	13 82       	std	Z+3, r1	; 0x03
    2118:	77 83       	std	Z+7, r23	; 0x07
    211a:	66 83       	std	Z+6, r22	; 0x06
    211c:	55 83       	std	Z+5, r21	; 0x05
    211e:	44 83       	std	Z+4, r20	; 0x04
    2120:	81 e4       	ldi	r24, 0x41	; 65
    2122:	90 e1       	ldi	r25, 0x10	; 16
    2124:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <SLIP_Init>
    2128:	60 e3       	ldi	r22, 0x30	; 48
    212a:	71 e0       	ldi	r23, 0x01	; 1
    212c:	ce 01       	movw	r24, r28
    212e:	02 96       	adiw	r24, 0x02	; 2
    2130:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <SLIP_SetRxBuffer>
    2134:	df 91       	pop	r29
    2136:	cf 91       	pop	r28
    2138:	08 95       	ret

0000213a <WiMOD_HCI_SendMessage>:
//
//------------------------------------------------------------------------------

int
WiMOD_HCI_SendMessage(TWiMOD_HCI_Message* txMessage)
{
    213a:	0f 93       	push	r16
    213c:	1f 93       	push	r17
    213e:	cf 93       	push	r28
    2140:	df 93       	push	r29
	// 1. check parameter
	//
	// 1.1 check ptr
	//
	if(!txMessage)
    2142:	00 97       	sbiw	r24, 0x00	; 0
    2144:	69 f1       	breq	.+90     	; 0x21a0 <WiMOD_HCI_SendMessage+0x66>
    2146:	ec 01       	movw	r28, r24
		// error
		return -1;
	}
	
	// 2. Calculate CRC16 over header and optional payload
	UINT16 crc16 = CRC16_Calc(&txMessage->SapID,
    2148:	8c 01       	movw	r16, r24
    214a:	0e 5f       	subi	r16, 0xFE	; 254
    214c:	1f 4f       	sbci	r17, 0xFF	; 255
    214e:	68 81       	ld	r22, Y
    2150:	79 81       	ldd	r23, Y+1	; 0x01
    2152:	6e 5f       	subi	r22, 0xFE	; 254
    2154:	7f 4f       	sbci	r23, 0xFF	; 255
    2156:	4f ef       	ldi	r20, 0xFF	; 255
    2158:	5f ef       	ldi	r21, 0xFF	; 255
    215a:	c8 01       	movw	r24, r16
    215c:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <CRC16_Calc>
	txMessage->Length + WIMOD_HCI_MSG_HEADER_SIZE,
	CRC16_INIT_VALUE);
	
	// 2.1 get 1's complement !!!
	crc16 = ~crc16;
    2160:	80 95       	com	r24
    2162:	90 95       	com	r25
	
	// 2.2 attach CRC16 and correct length, LSB first
	//
	txMessage->Payload[txMessage->Length]		= LOBYTE(crc16);
    2164:	28 81       	ld	r18, Y
    2166:	39 81       	ldd	r19, Y+1	; 0x01
    2168:	c2 0f       	add	r28, r18
    216a:	d3 1f       	adc	r29, r19
    216c:	8c 83       	std	Y+4, r24	; 0x04
	txMessage->Payload[txMessage->Length + 1]	= HIBYTE(crc16);
    216e:	9d 83       	std	Y+5, r25	; 0x05
	
	// 3. perform SLIP encoding
	// 	- start transmission with SAP ID
	// 	- correct length by header size
	
	int txLength = SLIP_EncodeData(TxBuffer,
    2170:	2c 5f       	subi	r18, 0xFC	; 252
    2172:	3f 4f       	sbci	r19, 0xFF	; 255
    2174:	a8 01       	movw	r20, r16
    2176:	66 e6       	ldi	r22, 0x66	; 102
    2178:	72 e0       	ldi	r23, 0x02	; 2
    217a:	89 e4       	ldi	r24, 0x49	; 73
    217c:	94 e0       	ldi	r25, 0x04	; 4
    217e:	0e 94 00 10 	call	0x2000	; 0x2000 <SLIP_EncodeData>
									sizeof(TxBuffer),
									&txMessage->SapID,
									txMessage->Length + WIMOD_HCI_MSG_HEADER_SIZE + WIMOD_HCI_MSG_FCS_SIZE);
	
	// message ok?
	if(txLength > 0)
    2182:	18 16       	cp	r1, r24
    2184:	19 06       	cpc	r1, r25
    2186:	5c f4       	brge	.+22     	; 0x219e <WiMOD_HCI_SendMessage+0x64>
	{
		// 4. send octet sequence over serial device
		/* Send via UART to radio module */
		if( uart1_tx_packet(TxBuffer, txLength) > 0 )
    2188:	bc 01       	movw	r22, r24
    218a:	89 e4       	ldi	r24, 0x49	; 73
    218c:	94 e0       	ldi	r25, 0x04	; 4
    218e:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <uart1_tx_packet>
    2192:	18 16       	cp	r1, r24
    2194:	19 06       	cpc	r1, r25
    2196:	3c f0       	brlt	.+14     	; 0x21a6 <WiMOD_HCI_SendMessage+0x6c>
			
			return 1;
		}
		
		// error - SLIP layer couldn't encode message - buffer to small?
		return -1;
    2198:	8f ef       	ldi	r24, 0xFF	; 255
    219a:	9f ef       	ldi	r25, 0xFF	; 255
    219c:	06 c0       	rjmp	.+12     	; 0x21aa <WiMOD_HCI_SendMessage+0x70>
	}
}
    219e:	05 c0       	rjmp	.+10     	; 0x21aa <WiMOD_HCI_SendMessage+0x70>
	// 1.1 check ptr
	//
	if(!txMessage)
	{
		// error
		return -1;
    21a0:	8f ef       	ldi	r24, 0xFF	; 255
    21a2:	9f ef       	ldi	r25, 0xFF	; 255
    21a4:	02 c0       	rjmp	.+4      	; 0x21aa <WiMOD_HCI_SendMessage+0x70>
		/* Send via UART to radio module */
		if( uart1_tx_packet(TxBuffer, txLength) > 0 )
		{
			// return ok
			
			return 1;
    21a6:	81 e0       	ldi	r24, 0x01	; 1
    21a8:	90 e0       	ldi	r25, 0x00	; 0
		}
		
		// error - SLIP layer couldn't encode message - buffer to small?
		return -1;
	}
}
    21aa:	df 91       	pop	r29
    21ac:	cf 91       	pop	r28
    21ae:	1f 91       	pop	r17
    21b0:	0f 91       	pop	r16
    21b2:	08 95       	ret

000021b4 <send_system_info_radio>:




void send_system_info_radio(void)
{
    21b4:	cf 93       	push	r28
    21b6:	df 93       	push	r29
    21b8:	cd b7       	in	r28, 0x3d	; 61
    21ba:	de b7       	in	r29, 0x3e	; 62
    21bc:	c2 53       	subi	r28, 0x32	; 50
    21be:	d1 40       	sbci	r29, 0x01	; 1
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	de bf       	out	0x3e, r29	; 62
    21c6:	0f be       	out	0x3f, r0	; 63
    21c8:	cd bf       	out	0x3d, r28	; 61
	/* Send data per WiMOD interface */
	// Test message
	TWiMOD_HCI_Message testMsg;
	testMsg.SapID = RADIOLINK_ID;		
    21ca:	83 e0       	ldi	r24, 0x03	; 3
    21cc:	8b 83       	std	Y+3, r24	; 0x03
	testMsg.MsgID = RADIOLINK_MSG_SEND_U_DATA_REQ; 
    21ce:	81 e0       	ldi	r24, 0x01	; 1
    21d0:	8c 83       	std	Y+4, r24	; 0x04
	testMsg.Payload[0] = GROUP_ADDR;			// Dst. Group Addr
    21d2:	85 e2       	ldi	r24, 0x25	; 37
    21d4:	8d 83       	std	Y+5, r24	; 0x05
	testMsg.Payload[1] = 0x34;				// Dst. Device Addr low-byte
    21d6:	84 e3       	ldi	r24, 0x34	; 52
    21d8:	8e 83       	std	Y+6, r24	; 0x06
	testMsg.Payload[2] = 0x12;				// Dst. Device Addr high-byte
    21da:	82 e1       	ldi	r24, 0x12	; 18
    21dc:	8f 83       	std	Y+7, r24	; 0x07
	testMsg.Payload[3] = 0;
    21de:	18 86       	std	Y+8, r1	; 0x08
	testMsg.Payload[4] = 0;
    21e0:	19 86       	std	Y+9, r1	; 0x09
	testMsg.Payload[5] = 0;
    21e2:	1a 86       	std	Y+10, r1	; 0x0a
	testMsg.Payload[6] = 0;
    21e4:	1b 86       	std	Y+11, r1	; 0x0b
	testMsg.CRC16[0] = 0;
    21e6:	cf 5c       	subi	r28, 0xCF	; 207
    21e8:	de 4f       	sbci	r29, 0xFE	; 254
    21ea:	18 82       	st	Y, r1
    21ec:	c1 53       	subi	r28, 0x31	; 49
    21ee:	d1 40       	sbci	r29, 0x01	; 1
	testMsg.CRC16[1] = 0;
    21f0:	ce 5c       	subi	r28, 0xCE	; 206
    21f2:	de 4f       	sbci	r29, 0xFE	; 254
    21f4:	18 82       	st	Y, r1
    21f6:	c2 53       	subi	r28, 0x32	; 50
    21f8:	d1 40       	sbci	r29, 0x01	; 1
	testMsg.Length = 7;		// is size of payload field so: (SapID, MsgID | Payload | CRC ) without (SapID, MsgID) and (CRC)
    21fa:	87 e0       	ldi	r24, 0x07	; 7
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	9a 83       	std	Y+2, r25	; 0x02
    2200:	89 83       	std	Y+1, r24	; 0x01
	
	//_delay_ms(1);

	WiMOD_HCI_SendMessage(&testMsg);
    2202:	ce 01       	movw	r24, r28
    2204:	01 96       	adiw	r24, 0x01	; 1
    2206:	0e 94 9d 10 	call	0x213a	; 0x213a <WiMOD_HCI_SendMessage>
}
    220a:	ce 5c       	subi	r28, 0xCE	; 206
    220c:	de 4f       	sbci	r29, 0xFE	; 254
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	de bf       	out	0x3e, r29	; 62
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	cd bf       	out	0x3d, r28	; 61
    2218:	df 91       	pop	r29
    221a:	cf 91       	pop	r28
    221c:	08 95       	ret

0000221e <wimod_rx_callback>:
}


TWiMOD_HCI_Message*
wimod_rx_callback(TWiMOD_HCI_Message* rxMessage)
{
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	ec 01       	movw	r28, r24
	// 	uart0_tx_byte(&rxMessage->SapID);
	// 	uart0_tx_byte(&rxMessage->MsgID);
	// 	uart0_tx_packet(&rxMessage->Payload, rxMessage->Length);
	//uart0_tx_byte(&brk);
	
	switch(rxMessage->SapID){
    2224:	8a 81       	ldd	r24, Y+2	; 0x02
    2226:	81 30       	cpi	r24, 0x01	; 1
    2228:	19 f0       	breq	.+6      	; 0x2230 <wimod_rx_callback+0x12>
    222a:	83 30       	cpi	r24, 0x03	; 3
    222c:	79 f0       	breq	.+30     	; 0x224c <wimod_rx_callback+0x2e>
    222e:	25 c0       	rjmp	.+74     	; 0x227a <wimod_rx_callback+0x5c>
 * </code>
 */

static void process_devmgmgt(TWiMOD_HCI_Message * rxMessage)
{
	switch(rxMessage->MsgID){
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	82 31       	cpi	r24, 0x12	; 18
    2234:	31 f0       	breq	.+12     	; 0x2242 <wimod_rx_callback+0x24>
    2236:	83 31       	cpi	r24, 0x13	; 19
    2238:	01 f5       	brne	.+64     	; 0x227a <wimod_rx_callback+0x5c>
		case DEVMGMT_MSG_GET_RADIO_CONFIG_REQ:
		uart0_tx_byte(&SLIP_END);
    223a:	85 e4       	ldi	r24, 0x45	; 69
    223c:	91 e0       	ldi	r25, 0x01	; 1
    223e:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <uart0_tx_byte>
		case DEVMGMT_MSG_SET_RADIO_CONFIG_RSP:
		uart0_tx_byte(&SLIP_END);
    2242:	85 e4       	ldi	r24, 0x45	; 69
    2244:	91 e0       	ldi	r25, 0x01	; 1
    2246:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <uart0_tx_byte>
    224a:	17 c0       	rjmp	.+46     	; 0x227a <wimod_rx_callback+0x5c>
}

static void process_radiolink(TWiMOD_HCI_Message * rxMessage)
{
	//uart0_tx_packet(&rxMessage->Payload, rxMessage->Length);
	switch(rxMessage->MsgID){
    224c:	8b 81       	ldd	r24, Y+3	; 0x03
    224e:	84 30       	cpi	r24, 0x04	; 4
    2250:	59 f0       	breq	.+22     	; 0x2268 <wimod_rx_callback+0x4a>
    2252:	86 30       	cpi	r24, 0x06	; 6
    2254:	61 f0       	breq	.+24     	; 0x226e <wimod_rx_callback+0x50>
    2256:	82 30       	cpi	r24, 0x02	; 2
    2258:	81 f4       	brne	.+32     	; 0x227a <wimod_rx_callback+0x5c>
		case RADIOLINK_MSG_SEND_U_DATA_RSP:
		uart0_tx_packet(&rxMessage->Payload, rxMessage->Length);
    225a:	68 81       	ld	r22, Y
    225c:	79 81       	ldd	r23, Y+1	; 0x01
    225e:	ce 01       	movw	r24, r28
    2260:	04 96       	adiw	r24, 0x04	; 4
    2262:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <uart0_tx_packet>
    2266:	09 c0       	rjmp	.+18     	; 0x227a <wimod_rx_callback+0x5c>
		break;
		case RADIOLINK_MSG_U_DATA_RX_IND:
		//uart0_tx_packet(&rxMessage->Payload, rxMessage->Length);
		send_system_info_radio();
    2268:	0e 94 da 10 	call	0x21b4	; 0x21b4 <send_system_info_radio>
    226c:	06 c0       	rjmp	.+12     	; 0x227a <wimod_rx_callback+0x5c>
		break;
		case RADIOLINK_MSG_U_DATA_TX_IND:
		uart0_tx_packet(&rxMessage->Payload, rxMessage->Length);
    226e:	68 81       	ld	r22, Y
    2270:	79 81       	ldd	r23, Y+1	; 0x01
    2272:	ce 01       	movw	r24, r28
    2274:	04 96       	adiw	r24, 0x04	; 4
    2276:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <uart0_tx_packet>
		default:
		// Should not happen..
		break;
	}

	memset(rxMessage, 0, sizeof(TWiMOD_HCI_Message));
    227a:	82 e3       	ldi	r24, 0x32	; 50
    227c:	91 e0       	ldi	r25, 0x01	; 1
    227e:	fe 01       	movw	r30, r28
    2280:	9c 01       	movw	r18, r24
    2282:	11 92       	st	Z+, r1
    2284:	21 50       	subi	r18, 0x01	; 1
    2286:	30 40       	sbci	r19, 0x00	; 0
    2288:	e1 f7       	brne	.-8      	; 0x2282 <wimod_rx_callback+0x64>
	return rxMessage;
}
    228a:	ce 01       	movw	r24, r28
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	08 95       	ret

00002292 <__cmpsf2>:
    2292:	0e 94 8b 11 	call	0x2316	; 0x2316 <__fp_cmp>
    2296:	08 f4       	brcc	.+2      	; 0x229a <__cmpsf2+0x8>
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	08 95       	ret

0000229c <__floatunsisf>:
    229c:	e8 94       	clt
    229e:	09 c0       	rjmp	.+18     	; 0x22b2 <__floatsisf+0x12>

000022a0 <__floatsisf>:
    22a0:	97 fb       	bst	r25, 7
    22a2:	3e f4       	brtc	.+14     	; 0x22b2 <__floatsisf+0x12>
    22a4:	90 95       	com	r25
    22a6:	80 95       	com	r24
    22a8:	70 95       	com	r23
    22aa:	61 95       	neg	r22
    22ac:	7f 4f       	sbci	r23, 0xFF	; 255
    22ae:	8f 4f       	sbci	r24, 0xFF	; 255
    22b0:	9f 4f       	sbci	r25, 0xFF	; 255
    22b2:	99 23       	and	r25, r25
    22b4:	a9 f0       	breq	.+42     	; 0x22e0 <__floatsisf+0x40>
    22b6:	f9 2f       	mov	r31, r25
    22b8:	96 e9       	ldi	r25, 0x96	; 150
    22ba:	bb 27       	eor	r27, r27
    22bc:	93 95       	inc	r25
    22be:	f6 95       	lsr	r31
    22c0:	87 95       	ror	r24
    22c2:	77 95       	ror	r23
    22c4:	67 95       	ror	r22
    22c6:	b7 95       	ror	r27
    22c8:	f1 11       	cpse	r31, r1
    22ca:	f8 cf       	rjmp	.-16     	; 0x22bc <__floatsisf+0x1c>
    22cc:	fa f4       	brpl	.+62     	; 0x230c <__floatsisf+0x6c>
    22ce:	bb 0f       	add	r27, r27
    22d0:	11 f4       	brne	.+4      	; 0x22d6 <__floatsisf+0x36>
    22d2:	60 ff       	sbrs	r22, 0
    22d4:	1b c0       	rjmp	.+54     	; 0x230c <__floatsisf+0x6c>
    22d6:	6f 5f       	subi	r22, 0xFF	; 255
    22d8:	7f 4f       	sbci	r23, 0xFF	; 255
    22da:	8f 4f       	sbci	r24, 0xFF	; 255
    22dc:	9f 4f       	sbci	r25, 0xFF	; 255
    22de:	16 c0       	rjmp	.+44     	; 0x230c <__floatsisf+0x6c>
    22e0:	88 23       	and	r24, r24
    22e2:	11 f0       	breq	.+4      	; 0x22e8 <__floatsisf+0x48>
    22e4:	96 e9       	ldi	r25, 0x96	; 150
    22e6:	11 c0       	rjmp	.+34     	; 0x230a <__floatsisf+0x6a>
    22e8:	77 23       	and	r23, r23
    22ea:	21 f0       	breq	.+8      	; 0x22f4 <__floatsisf+0x54>
    22ec:	9e e8       	ldi	r25, 0x8E	; 142
    22ee:	87 2f       	mov	r24, r23
    22f0:	76 2f       	mov	r23, r22
    22f2:	05 c0       	rjmp	.+10     	; 0x22fe <__floatsisf+0x5e>
    22f4:	66 23       	and	r22, r22
    22f6:	71 f0       	breq	.+28     	; 0x2314 <__floatsisf+0x74>
    22f8:	96 e8       	ldi	r25, 0x86	; 134
    22fa:	86 2f       	mov	r24, r22
    22fc:	70 e0       	ldi	r23, 0x00	; 0
    22fe:	60 e0       	ldi	r22, 0x00	; 0
    2300:	2a f0       	brmi	.+10     	; 0x230c <__floatsisf+0x6c>
    2302:	9a 95       	dec	r25
    2304:	66 0f       	add	r22, r22
    2306:	77 1f       	adc	r23, r23
    2308:	88 1f       	adc	r24, r24
    230a:	da f7       	brpl	.-10     	; 0x2302 <__floatsisf+0x62>
    230c:	88 0f       	add	r24, r24
    230e:	96 95       	lsr	r25
    2310:	87 95       	ror	r24
    2312:	97 f9       	bld	r25, 7
    2314:	08 95       	ret

00002316 <__fp_cmp>:
    2316:	99 0f       	add	r25, r25
    2318:	00 08       	sbc	r0, r0
    231a:	55 0f       	add	r21, r21
    231c:	aa 0b       	sbc	r26, r26
    231e:	e0 e8       	ldi	r30, 0x80	; 128
    2320:	fe ef       	ldi	r31, 0xFE	; 254
    2322:	16 16       	cp	r1, r22
    2324:	17 06       	cpc	r1, r23
    2326:	e8 07       	cpc	r30, r24
    2328:	f9 07       	cpc	r31, r25
    232a:	c0 f0       	brcs	.+48     	; 0x235c <__fp_cmp+0x46>
    232c:	12 16       	cp	r1, r18
    232e:	13 06       	cpc	r1, r19
    2330:	e4 07       	cpc	r30, r20
    2332:	f5 07       	cpc	r31, r21
    2334:	98 f0       	brcs	.+38     	; 0x235c <__fp_cmp+0x46>
    2336:	62 1b       	sub	r22, r18
    2338:	73 0b       	sbc	r23, r19
    233a:	84 0b       	sbc	r24, r20
    233c:	95 0b       	sbc	r25, r21
    233e:	39 f4       	brne	.+14     	; 0x234e <__fp_cmp+0x38>
    2340:	0a 26       	eor	r0, r26
    2342:	61 f0       	breq	.+24     	; 0x235c <__fp_cmp+0x46>
    2344:	23 2b       	or	r18, r19
    2346:	24 2b       	or	r18, r20
    2348:	25 2b       	or	r18, r21
    234a:	21 f4       	brne	.+8      	; 0x2354 <__fp_cmp+0x3e>
    234c:	08 95       	ret
    234e:	0a 26       	eor	r0, r26
    2350:	09 f4       	brne	.+2      	; 0x2354 <__fp_cmp+0x3e>
    2352:	a1 40       	sbci	r26, 0x01	; 1
    2354:	a6 95       	lsr	r26
    2356:	8f ef       	ldi	r24, 0xFF	; 255
    2358:	81 1d       	adc	r24, r1
    235a:	81 1d       	adc	r24, r1
    235c:	08 95       	ret

0000235e <__gesf2>:
    235e:	0e 94 8b 11 	call	0x2316	; 0x2316 <__fp_cmp>
    2362:	08 f4       	brcc	.+2      	; 0x2366 <__gesf2+0x8>
    2364:	8f ef       	ldi	r24, 0xFF	; 255
    2366:	08 95       	ret

00002368 <__udivmodsi4>:
    2368:	a1 e2       	ldi	r26, 0x21	; 33
    236a:	1a 2e       	mov	r1, r26
    236c:	aa 1b       	sub	r26, r26
    236e:	bb 1b       	sub	r27, r27
    2370:	fd 01       	movw	r30, r26
    2372:	0d c0       	rjmp	.+26     	; 0x238e <__udivmodsi4_ep>

00002374 <__udivmodsi4_loop>:
    2374:	aa 1f       	adc	r26, r26
    2376:	bb 1f       	adc	r27, r27
    2378:	ee 1f       	adc	r30, r30
    237a:	ff 1f       	adc	r31, r31
    237c:	a2 17       	cp	r26, r18
    237e:	b3 07       	cpc	r27, r19
    2380:	e4 07       	cpc	r30, r20
    2382:	f5 07       	cpc	r31, r21
    2384:	20 f0       	brcs	.+8      	; 0x238e <__udivmodsi4_ep>
    2386:	a2 1b       	sub	r26, r18
    2388:	b3 0b       	sbc	r27, r19
    238a:	e4 0b       	sbc	r30, r20
    238c:	f5 0b       	sbc	r31, r21

0000238e <__udivmodsi4_ep>:
    238e:	66 1f       	adc	r22, r22
    2390:	77 1f       	adc	r23, r23
    2392:	88 1f       	adc	r24, r24
    2394:	99 1f       	adc	r25, r25
    2396:	1a 94       	dec	r1
    2398:	69 f7       	brne	.-38     	; 0x2374 <__udivmodsi4_loop>
    239a:	60 95       	com	r22
    239c:	70 95       	com	r23
    239e:	80 95       	com	r24
    23a0:	90 95       	com	r25
    23a2:	9b 01       	movw	r18, r22
    23a4:	ac 01       	movw	r20, r24
    23a6:	bd 01       	movw	r22, r26
    23a8:	cf 01       	movw	r24, r30
    23aa:	08 95       	ret

000023ac <__umulhisi3>:
    23ac:	a2 9f       	mul	r26, r18
    23ae:	b0 01       	movw	r22, r0
    23b0:	b3 9f       	mul	r27, r19
    23b2:	c0 01       	movw	r24, r0
    23b4:	a3 9f       	mul	r26, r19
    23b6:	70 0d       	add	r23, r0
    23b8:	81 1d       	adc	r24, r1
    23ba:	11 24       	eor	r1, r1
    23bc:	91 1d       	adc	r25, r1
    23be:	b2 9f       	mul	r27, r18
    23c0:	70 0d       	add	r23, r0
    23c2:	81 1d       	adc	r24, r1
    23c4:	11 24       	eor	r1, r1
    23c6:	91 1d       	adc	r25, r1
    23c8:	08 95       	ret

000023ca <memcpy>:
    23ca:	fb 01       	movw	r30, r22
    23cc:	dc 01       	movw	r26, r24
    23ce:	02 c0       	rjmp	.+4      	; 0x23d4 <memcpy+0xa>
    23d0:	01 90       	ld	r0, Z+
    23d2:	0d 92       	st	X+, r0
    23d4:	41 50       	subi	r20, 0x01	; 1
    23d6:	50 40       	sbci	r21, 0x00	; 0
    23d8:	d8 f7       	brcc	.-10     	; 0x23d0 <memcpy+0x6>
    23da:	08 95       	ret

000023dc <_exit>:
    23dc:	f8 94       	cli

000023de <__stop_program>:
    23de:	ff cf       	rjmp	.-2      	; 0x23de <__stop_program>
